<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Go使用Jaeger实现分布式链路追踪</title>
    <link href="/2021/12/14/Go%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/"/>
    <url>/2021/12/14/Go%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</url>
    
    <content type="html"><![CDATA[<h1 id="了解分布式链路追踪"><a href="#了解分布式链路追踪" class="headerlink" title="了解分布式链路追踪"></a>了解分布式链路追踪</h1><h2 id="什么是分布式链路追踪？"><a href="#什么是分布式链路追踪？" class="headerlink" title="什么是分布式链路追踪？"></a>什么是分布式链路追踪？</h2><ul><li>分布式链路追踪式用来查看和了解复杂的微服务间交互中的整个活动链</li><li>现代的云原生软件开发十分依赖微服务，因为每个独立的服务提供不同的核心功能。当用户在应用中发出请求时，许多单独的服务器都会作出响应，产生相应的结果</li><li>应用中的一个调用可能会涉及几十项彼此交互的服务。当出现问题时，开发人员和工程师该如何查明问题所在？所以需要一种跟踪所有连接的方法，就是分布式链路追踪</li></ul><h2 id="什么是OpenTracing"><a href="#什么是OpenTracing" class="headerlink" title="什么是OpenTracing?"></a>什么是OpenTracing?</h2><p><code>OpenTracing</code>是CNCF托管的分布式追踪项目，官方定位是针对分布式系统的追踪的API标准库，旨在为不同的分布式追踪系统提供统一的对外API接入层。它位于<strong>应用程序/类库</strong>和<strong>追踪或日志分析程序</strong>之间。</p><blockquote><p><strong>OpenTracing 数据模型</strong></p></blockquote><ul><li><p><strong>Trace</strong> 事物在分布式系统中移动时的描述</p></li><li><p><strong>Span</strong> 一种命名的、定时的操作，表示工作流的一部分，<code>span</code>中包含一下状态</p><ul><li><strong>Span Tag</strong>，一组键值对构成的 Span 标签集合。键值对中，键必须为 string，值可以是字符串，布尔，或者数字类型。</li><li><strong>Span Log</strong>，一组 span 的日志集合。每次 log 操作包含一个键值对，以及一个时间戳。</li></ul></li><li><p><strong>Span Contenxt</strong> 携带分布式事务的跟踪信息，包括当它通过网络或消息总线将服务传递给服务时。Span上下文包含Trace标识符、Span标识符和跟踪系统需要传播到下游服务的任何其他数据</p></li></ul><p>特别说明，一条 <strong>Trace</strong>（调用链）可以被认为是一个由多个 <strong>Span</strong> 组成的有向无环图（DAG图），<strong>Span</strong> 与 <strong>Span</strong> 的关系被命名为 <strong>References</strong>。Trace调用链可以用树形结构或者基于时间轴的时序图表示。下图为树形结构表示调用关系：</p><p><img src="/img/Go%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/image-20211202102756151.png" alt="image-20211202102756151"></p><p>有时，使用<strong>时间轴</strong>来可视化Trace会更容易，如下图</p><p><img src="/img/Go%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/image-20211202102729427.png" alt="image-20211202102729427"></p><h2 id="什么是Jaeger"><a href="#什么是Jaeger" class="headerlink" title="什么是Jaeger?"></a>什么是Jaeger?</h2><p>分布式追踪系统种类繁多，但是核心步骤有三个：代码埋点、数据存储和查询展示</p><p>Jaeger是Uber推出的一款开源分布式追踪系统，<strong>兼容OpenTracing API</strong>，它用于<strong>监视和诊断基于微服务的分布式系统</strong>，分布式追踪系统用于记录请求范围内的信息，例如：一次远程方法调用的执行过程和耗时。是我们排查问题和系统性能的利器</p><blockquote><p><strong>Jaeger的优点</strong></p></blockquote><ul><li>兼容<code>OpenTracing AP</code>I，写起来方便简单</li><li><code>UI</code>相较于Zipkin更加直观和丰富</li><li><code>sdk</code>比较丰富，go语言编写，支持Go、Java、Python、C++、C#、Node</li><li>上传采用<code>udp</code>传输，效率高速度快</li><li>后台存储支持<code>Cassandra</code>、<code>es</code>、<code>kafka</code></li></ul><blockquote><p><strong>Jaeger架构图</strong></p></blockquote><p><img src="/img/Go%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/image-20211202105921391.png" alt="image-20211202105921391"></p><blockquote><p><strong>Jaeger组件介绍</strong></p></blockquote><ul><li><p><strong>jaeger-client</strong>：<code>jaeger</code> 的客户端，实现了<code>opentracing</code>协议 开销很小</p></li><li><p><strong>jaeger-agent</strong>：<code>jaeger client</code>的一个代理程序，client将收集到的调用链数据发给agent，然后由agent发给collector</p></li><li><p><strong>jaeger-collector</strong>：负责接收<code>jaeger client</code>或者<code>jaeger agent</code>上报上来的调用链数据，然后做一些校验，比如时间范围是否合法等，最终会经过内部的处理存储到后端存储</p></li><li><p><strong>jaeger-query</strong>：专门负责调用链查询的一个服务，有自己独立的UI</p></li><li><p><strong>jaeger-ingester</strong>：中文名称“摄食者”，可用从kafka读取数据然后写到<code>jaeger</code>的后端存储，比如<code>Cassandra</code>和<code>Elasticsearch</code></p></li></ul><p>其中j<code>aeger-collector</code>和<code>jaeger-query</code>是必须的，其余的都是可选的，我们没有采用<code>agent</code>上报的方式，而是让客户端直接通过<code>endpoint</code>上报到<code>collector</code>。</p><h1 id="使用Jaeger"><a href="#使用Jaeger" class="headerlink" title="使用Jaeger"></a>使用Jaeger</h1><blockquote><p><strong>引用相关库</strong></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get -u github.com/opentracing/opentracing-<span class="hljs-keyword">go</span><br><span class="hljs-keyword">go</span> get -u github.com/uber/jaeger-client-<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p><strong>使用Jaeger</strong></p></blockquote><p><strong>初始化jaeger</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>tracer opentracing.Tracer<br>closer io.Closer<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initJaeger</span><span class="hljs-params">(serviceName <span class="hljs-keyword">string</span>)</span></span>&#123;<br>cfg := &amp;config.Configuration&#123;<br>    Sampler: &amp;config.SamplerConfig&#123; <span class="hljs-comment">//采样类型设置</span><br>        Type:  <span class="hljs-string">&quot;const&quot;</span>, <br>        Param: <span class="hljs-number">1</span>,<br>    &#125;,<br>    Reporter: &amp;config.ReporterConfig&#123; <span class="hljs-comment">// 采样接口设置</span><br>        LogSpans: <span class="hljs-literal">true</span>,<br>        LocalAgentHostPort:<span class="hljs-string">&quot;xxx:6831&quot;</span>,<br>    &#125;,<br>&#125;<br>cfg.ServiceName = serviceName <span class="hljs-comment">// 采集服务器名字 是必要的</span><br><br>tracer, closer, _ = cfg.NewTracer( <span class="hljs-comment">// 生成jaeger tracer</span><br>config.Logger(jaeger.StdLogger), <span class="hljs-comment">// 每次调用时打印日志</span><br>)<br><br>opentracing.SetGlobalTracer(tracer) <span class="hljs-comment">// 生成全局单例tracer   </span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>SamplerConfig</code>用于设置采样类型，<code>Type</code>分为：</p><ul><li><strong>const</strong>：全量采集。<code>param</code>采样率设置0,1 分别对应打开和关闭</li><li><strong>probabilistic</strong> ：概率采集。<code>param</code>默认万份之一，0~1之间取值，</li><li><strong>rateLimiting</strong> ：限速采集。<code>param</code>每秒采样的个数</li><li><strong>remote</strong> ：动态采集策略。<code>param</code>值与<code>probabilistic</code>的参数一样。在收到实际值之前的初始采样率。改值可以通过环境变量的<code>JAEGER_SAMPLER_PARAM</code>设定</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">记录关于Span相关信息<br><span class="hljs-comment">//method 1、Adds a tag to the span.</span><br>SetTag(key <span class="hljs-keyword">string</span>, value <span class="hljs-keyword">interface</span>&#123;&#125;) Span<br><br><span class="hljs-comment">//method 2、有类型检查、但相较LogKV比较麻烦</span><br>LogFields(fields ...log.Field)<br><br><span class="hljs-comment">//method 3、缺乏类型检查</span><br>LogKV(alternatingKeyValues ...<span class="hljs-keyword">interface</span>&#123;&#125;)<br></code></pre></td></tr></table></figure><p>​    </p><p><strong>在最初调用时(放在中间件等)生成ctx，并将span注入进去</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">span, ctx := opentracing.StartSpanFromContext(ctx, name) <span class="hljs-comment">// 开始生成子span</span><br><span class="hljs-keyword">defer</span> span.Finish()<br></code></pre></td></tr></table></figure><p>​    </p><p><strong>通过ctx拿到span，可以将kv注入进去</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setSpanLog</span><span class="hljs-params">(ctx context.Context,msg <span class="hljs-keyword">string</span>,level <span class="hljs-keyword">string</span>)</span></span>&#123;<br>    span := opentracing.SpanFromContext(ctx) <span class="hljs-comment">// 获取ctx中的span</span><br>span.LogFields(log.String(<span class="hljs-string">&quot;event&quot;</span>, msg)) <span class="hljs-comment">// 注册kv键值对</span><br>    span.LogFields(log.String(<span class="hljs-string">&quot;level&quot;</span>, level))<br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><p><strong>将jaeger集成到micro中</strong></p><p><code>micro</code>插件中提供了4种<code>wrapper</code>，分别用于不同服务类型： <code>WrapHandler( )</code> server中间件 、<code>WrapCall( )</code> call中间件 、<code>WrapClient( )</code> client中间件 、 <code>WrapSubscriber( ) </code>订阅中间件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go">srv := micro.NewService(<br>micro.WrapClient(<br>opentracing.NewClientWrapper(trace.Tracer()),<br>logger.LogClient,<br>),<br>micro.WrapHandler(<br>opentracing.NewHandlerWrapper(trace.Tracer()),<br>logger.LogHandler,<br>),<br>    micro.WrapSubscriber(<br>opentracing.NewSubscriberWrapper(trace.Tracer()),<br>),<br>micro.WrapCall(<br>opentracing.NewCallWrapper(trace.Tracer()), <br>),<br>)<br></code></pre></td></tr></table></figure><h1 id="测试部署"><a href="#测试部署" class="headerlink" title="测试部署"></a>测试部署</h1><blockquote><p><strong>快速搭建环境</strong></p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="bash"> -d -e COLLECTOR_ZIPKIN_HTTP_PORT=9411 -p5775:5775/udp -p6831:6831/udp -p6832:6832/udp \</span><br><span class="bash">  -p5778:5778 -p16686:16686 -p14268:14268 -p9411:9411 jaegertracing/all-in-one:latest</span><br></code></pre></td></tr></table></figure><p>​    </p><table><thead><tr><th>端口</th><th>协议</th><th>组件</th><th>功能</th></tr></thead><tbody><tr><td>5775</td><td>UDP协议</td><td>agent</td><td>接受zipkin.thrift紧凑型节俭协议（不推荐使用，仅由旧版客户端使用）</td></tr><tr><td>6831</td><td>UDP协议</td><td>agent</td><td>接受jaeger.thrift紧凑型节俭协议</td></tr><tr><td>6832</td><td>UDP协议</td><td>agent</td><td>jaeger.thrift通过二进制节俭协议接受</td></tr><tr><td>5778</td><td>HTTP</td><td>agent</td><td>服务配置</td></tr><tr><td>16686</td><td>HTTP</td><td>query</td><td>服务前端</td></tr><tr><td>14268</td><td>HTTP</td><td>collector</td><td>jaeger.thrift直接接受客户</td></tr><tr><td>14250</td><td>HTTP</td><td>collector</td><td>接受 model.proto</td></tr><tr><td>9411</td><td>HTTP</td><td>collector</td><td>Zipkin兼容端点（可选）</td></tr></tbody></table><p>​    </p><p>成功启动后，可以通过<code>http://xxx:16686</code>访问 <code>Jaeger-UI</code></p><p><img src="/img/Go%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/image-20211202141018674.png" alt="image-20211202141018674"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go标准化</title>
    <link href="/2021/10/15/Go%E4%BB%A3%E7%A0%81%E6%A0%87%E5%87%86%E5%8C%96/"/>
    <url>/2021/10/15/Go%E4%BB%A3%E7%A0%81%E6%A0%87%E5%87%86%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近将公司的一个项目代码进行初步的标准化，在过程中也有一些感悟和收获，进行简要的记录</p><p>项目代码注重标准化可以帮助我们写出高质量的代码</p><h1 id="Go写法标准化"><a href="#Go写法标准化" class="headerlink" title="Go写法标准化"></a>Go写法标准化</h1><ul><li><p>不要将<code>interface</code>做为万能的传递类型，不明确传递类型会降低代码的清晰度，<code>interface</code>类型可以代表任意类型，编译器不知道参数会是什么类型，只有运行时才知道，因此**只能分配到堆上(增加GC压力)**；并且如果接收方也是<code>interface</code>，则随意传递值会导致不可预估的后果(在twice中<code>db层</code>就用interface接收<code>control层</code>传的model是完全错误的)</p></li><li><p>变量和函数命名规范，要有意义，看名知意且尽量简介，驼峰命名，动作+对象，不要在函数里创建大写开头的变量</p></li></ul><ul><li><p>error返回</p><ul><li>关于<code>error</code>的原则是遇到err就进行判定<code>err!=nil</code>而不是<code>err==nil</code>，因为后者就会将正确包在括号里，一层一层如套娃一样，不美观也不优雅        </li></ul><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err==<span class="hljs-literal">nil</span>&#123;<br>    <span class="hljs-keyword">if</span> err==<span class="hljs-literal">nil</span>&#123;<br>        <br>    &#125;<span class="hljs-keyword">else</span>&#123;&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;&#125;<br><span class="hljs-comment">//修改为</span><br><span class="hljs-keyword">if</span> err!=<span class="hljs-literal">nil</span>&#123;<br>    <br>&#125;<br><span class="hljs-keyword">if</span> err!=<span class="hljs-literal">nil</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>遇到<code>err</code>就要进行处理，而不是用匿名变量，唯一的对<code>err</code>都不关心，除非对返回结果也不关心</p></li><li><p>很多说go语言语法丑陋的，就是因为错误的返回方式，但是在代码风格上也可以进行优化避免大量的 <code>if err!=nil</code></p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">err:=xxxFunction()<br><span class="hljs-keyword">if</span> err!=<span class="hljs-literal">nil</span>&#123;<br><br>&#125;<br><span class="hljs-comment">//修改为</span><br><span class="hljs-keyword">if</span> err:=xxxFunction();err!=<span class="hljs-literal">nil</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DBxxxOperate</span><span class="hljs-params">(xx model)</span><span class="hljs-title">error</span></span>&#123;<br>    err:=DB.Create(&amp;xx).Error<br>    <span class="hljs-keyword">if</span> err!=<span class="hljs-literal">nil</span>&#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>   <br>&#125;<br><span class="hljs-comment">//修改为</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DBxxxOperate</span><span class="hljs-params">(xx model)</span><span class="hljs-title">error</span></span>&#123;<br>    <span class="hljs-keyword">return</span> DB.Create(&amp;xx).Error  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>对野生goroutine进行兜底保护</strong></p><p>因为<code>gin</code>框架已经对每一个接口进行了兜底保护，即使发送panic也不会宕机(<code>panic</code>),但是如果在接口中使用了<strong>野生goroutine并且在里面发升了<code>panic</code>，那么整个程序都会崩溃！(包括主程序)</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <br>      <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//兜底保护</span><br>          <span class="hljs-keyword">if</span> err:=<span class="hljs-built_in">recover</span>();err!=<span class="hljs-literal">nil</span>&#123;<br>              logger(<span class="hljs-string">&quot;happen panic!&quot;</span>)<br>              ...<br>          &#125;<br>      &#125;<br>    xxx()<br>  &#125;()<br></code></pre></td></tr></table></figure></li></ul><h1 id="DB层标准化"><a href="#DB层标准化" class="headerlink" title="DB层标准化"></a>DB层标准化</h1><ul><li><p>返回时返回<code>error</code>而不是自定义的<code>rsp</code>结构体(从而到<code>control层</code>后直接作为数据返回给客户端)，<code>db层</code>只是完成数据库相关操作，如果在其他也需要该<code>db层</code>返回的数据并且不需要<code>rsp</code>这样重量级的返回，则需要返回到control会做进一步处理，并且会增加<code>db层</code>的耦合度</p></li><li><p>不要<code>在db层</code>做业务逻辑的操作，业务逻辑操作就该丢到<code>control层</code>，<code>db层</code>只用来做好数据库信息的操作即可，做到功能内聚</p><p>比如对查询到的数据数组进行进一步的操作时，需要将返回至<code>control层</code>再操作，而不是在<code>db层</code>操作后再返回给<code>control层</code></p></li><li><p><del>在db层的操作只有对于Find操作时需要传递指针的(因为只返回error)，其他关于Create、Update、Delete操作只需要传递值即可(如果不需要数据段Create和Update的时间信息)，项目中尽量减少指针传递的操作，避免频繁的内存逃逸增加Go的GC压力</del></p><p>最开始以为传入指针就会发生内存逃逸，后面发现并不是，具体请查看 <a href="https://snowyangyuxin.github.io/2021/07/30/Go%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/">Go逃逸分析详解</a></p></li><li><p>只有对于Find操作时需要传递指针的(因为要获取数据)，其他关于Create、Update、Delete操作只需要传递值即可(如果不需要数据段Create和Update的时间信息)，但是对于传值还是传指针，需要根据具体实际看(对于多字段的传值会有更多的<code>copy</code>操作)</p></li></ul><h1 id="Control层标准化"><a href="#Control层标准化" class="headerlink" title="Control层标准化"></a>Control层标准化</h1><ul><li>函数传递的值能少也要尽量少(前提是满足需求)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FindXxx</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> article model<br>    ...<br>    <span class="hljs-keyword">if</span> err:=DBxxxOperate(article.ID,article.Tag,&amp;article);err!=<span class="hljs-literal">nil</span>&#123;<br>        <br>    &#125;    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DBxxxFind</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>,tag <span class="hljs-keyword">string</span>,article *model)</span><span class="hljs-title">error</span></span>&#123;<br>    <span class="hljs-keyword">return</span> DB.Where(<span class="hljs-string">&quot;id=? AND type=?&quot;</span>,id,tag).Find(&amp;article).Error  <br>&#125;<br><span class="hljs-comment">//修改为</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FindXxx</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> article model<br>    ...<br>    <span class="hljs-keyword">if</span> err:=DBxxxOperate(&amp;article);err!=<span class="hljs-literal">nil</span>&#123;<br>        <br>    &#125;    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DBxxxFind</span><span class="hljs-params">(article *model)</span><span class="hljs-title">error</span></span>&#123;<br>    <span class="hljs-keyword">return</span> DB.Where(<span class="hljs-string">&quot;id=? AND type=?&quot;</span>,atricle.ID,article,Tag).Find(&amp;article).Error  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>要相信一个原则：<strong>永远不要相信前端给你传来的值</strong>，则对于前端传来的值都需要进行验证，比如delete时需要验证delete_id是否存在，因为就算不存在delete空也不会报错，而对于update更要验证update_id的存在，因为<strong>不存在的话update会在数据库创建一个update_id的对象</strong></li></ul><h1 id="Error返回标准化"><a href="#Error返回标准化" class="headerlink" title="Error返回标准化"></a>Error返回标准化</h1><p>对于API接口的调用返回也是非常重要的，对于返回最要使用同一的结构体进行封装(这样也是为了前端姿势同一和在进行测试时便利)</p><p>采用<code>Code</code>和<code>Data</code>的组合，<del>没有加入消息<code>Message</code></del>和错误<code>Error</code>，<strong>因为对于发生错误时是并不需要前端和客户端知道具体是什么错误</strong>，只需要知道错误码，而后端则可以通过错误码来查看具体api逻辑值错误的地方，而消息Message则可以写在日志中，需要时则进行查看</p><p><strong>更新：现在需要加入消息msg，因为这样前端在测试时才知道是自己出现了问题还是后端的问题</strong></p><p>因为只要是有相应，则说明客户端和服务器相应成功，都应该是返回200，所以设置新的错误码才能有利于去区分不同的错误类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Response <span class="hljs-keyword">struct</span> &#123;<br>   Code ErrCode     <span class="hljs-string">`json:&quot;code,omitempty&quot;`</span><br>   Msg  <span class="hljs-keyword">string</span>      <span class="hljs-string">`json:&quot;msg&quot;`</span><br>   Data <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-string">`json:&quot;data,omitempty&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> ErrCode <span class="hljs-keyword">int</span><br><br><span class="hljs-keyword">const</span> Success ErrCode = <span class="hljs-number">20000</span><br><br><span class="hljs-keyword">const</span> (<br>ErrService                ErrCode = <span class="hljs-number">1000</span><br>ErrBindJson                       = <span class="hljs-number">1001</span><br>    ...<br>)<br></code></pre></td></tr></table></figure><p>​    </p><p>对返回进行进一步封装，可分为成功有返回、成功无返回、错误(是为了在<code>control</code>层写时清晰，知道是哪一种返回类型)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ResSuccessData</span><span class="hljs-params">(c *gin.Context, data <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>   ResJson(c, Response&#123;Code: SuccessCode, Data: data&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ResSuccess</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>   ResJson(c, Response&#123;Code: SuccessCode&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ResErr</span><span class="hljs-params">(c *gin.Context, code ErrCode)</span></span> &#123;<br>   ResJson(c, Response&#123;Code: code&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ResJson</span><span class="hljs-params">(c *gin.Context, data <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>   c.JSON(http.StatusOK, data)<br>   c.Abort()<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在平时或工作中需要对自己代码进行严格的把控，对需要标准化的地方要仔细，这样才能写出高质量的代码</p><p>但是并不是在任何时候都要对代码标准化严格执行，在实际生产中，代码是需要在规定的时间进行产出，如果在任何时候任何地点严格把控代码就会大大拖慢项目进度</p><p>例如在error返回标准化时在项目最初是不需要对错误码进行规范等</p><p>但是在err优化操作、大小写字母命名这样的习惯则需要在任何时候养成</p>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用yml文件生成SwaggerAPI接口文档</title>
    <link href="/2021/10/15/%E4%BD%BF%E7%94%A8yml%E6%96%87%E4%BB%B6%E6%9E%84%E5%BB%BAswagger%E6%96%87%E6%A1%A3/"/>
    <url>/2021/10/15/%E4%BD%BF%E7%94%A8yml%E6%96%87%E4%BB%B6%E6%9E%84%E5%BB%BAswagger%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在，在程序开发中前后端分离的模式已经成了主流，而在前后端分离的项目中，如果后端的开发人员能提供一份清晰明了的接口文档，那么对接的前端开发人员也会轻松很多，<strong>大大的提高了前后端沟通效率和开发速度</strong></p><p><code>Swagger</code>可以用来定义和记录<code>RESTful Web</code>服务的接口文档，可以通过<strong>使用给接口代码添加申明式注释的方式</strong>、也可以<strong>使用yml文档格式</strong>来生成swagger渲染的前端接口文档界面</p><p>下面来介绍第二种：使用<code>yml</code>文档格式的方式来生成<code>swagger</code>渲染接口文档，用的是<strong>OpenAPI 3</strong>的标准</p><h1 id="yml文档规则"><a href="#yml文档规则" class="headerlink" title="yml文档规则"></a>yml文档规则</h1><figure class="highlight yaml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">openapi:</span> <span class="hljs-number">3.0</span><span class="hljs-number">.0</span> <span class="hljs-comment">#必填字段 指定swagger版本号</span><br><span class="hljs-attr">info:</span><br>  <span class="hljs-attr">description:</span> <span class="hljs-string">接口文档的总描述#接口文档描述</span><br>  <span class="hljs-attr">version:</span> <span class="hljs-string">&quot;1.1.0&quot;</span> <span class="hljs-comment">#文档版本</span><br>  <span class="hljs-attr">title:</span> <span class="hljs-string">test</span> <span class="hljs-string">服务</span> <span class="hljs-comment">#接口文档标题</span><br>  <span class="hljs-attr">contact:</span><br>    <span class="hljs-attr">email:</span> <span class="hljs-string">xxx@xxx.com</span> <span class="hljs-comment">#联系邮箱</span><br><span class="hljs-attr">servers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">description:</span> <span class="hljs-string">这是接口文档的IP端口地址</span> <span class="hljs-comment">#地址的描述</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">http://127.0.0.1:8080/</span> <span class="hljs-comment">#接口的IP端口地址</span><br><span class="hljs-attr">tags:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">服务接口组1</span><br>    <span class="hljs-attr">description:</span> <span class="hljs-string">这是接口组1的注释</span> <span class="hljs-comment">#给下面有相应标签的接口添加注释</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">用户</span><br>    <span class="hljs-attr">description:</span> <span class="hljs-string">这是接口用户组的注释</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E4%BD%BF%E7%94%A8yml%E6%96%87%E4%BB%B6%E6%9E%84%E5%BB%BAswagger%E6%96%87%E6%A1%A3/image-20210827100343400.png" alt="image-20210827100343400"></p><p>​    </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">paths:</span> <br>  <span class="hljs-string">/service-test/v1/login:</span><br>    <span class="hljs-attr">post:</span> <span class="hljs-comment">#必填字段,定义HTTP操作方法，必须是http协议定义的方法</span><br>      <span class="hljs-attr">tags:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">用户</span> <span class="hljs-comment">#能通过上面tag desc添加标签注释</span><br>      <span class="hljs-attr">summary:</span> <span class="hljs-string">用户登录</span> <span class="hljs-comment">#接口描述</span><br>      <span class="hljs-attr">parameters:</span> <span class="hljs-comment">#参数</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">SECRET_CODE</span><br>          <span class="hljs-attr">in:</span> <span class="hljs-string">header</span> <span class="hljs-comment">#参数参数的地方，可填header、path、query</span><br>          <span class="hljs-attr">description:</span> <span class="hljs-string">用户鉴权码</span><br>          <span class="hljs-attr">required:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#是否必填</span><br>          <span class="hljs-attr">schema:</span><br>            <span class="hljs-attr">type:</span> <span class="hljs-string">string</span> <span class="hljs-comment">#参数类型 可选的类型还有array、object、integer、string、boolean</span><br>      <span class="hljs-attr">requestBody:</span> <span class="hljs-comment">#请求结构体(如果有才写)</span><br>        <span class="hljs-attr">content:</span><br>          <span class="hljs-attr">application/json:</span> <span class="hljs-comment">#指定类型为json格式</span><br>            <span class="hljs-attr">schema:</span><br>              <span class="hljs-attr">type:</span> <span class="hljs-string">object</span> <br>              <span class="hljs-attr">example:</span> <span class="hljs-comment">#给出例子</span><br>                &#123;<br>                  <span class="hljs-string">&quot;phone&quot;</span><span class="hljs-string">:&quot;12345678910&quot;</span>,<br>                  <span class="hljs-string">&quot;password&quot;</span><span class="hljs-string">:&quot;123456&quot;</span><br>                &#125;<br>      <span class="hljs-attr">responses:</span> <span class="hljs-comment">#返回值(必要)</span><br>        <span class="hljs-attr">&#x27;200&#x27;:</span> <span class="hljs-comment">#返回成功</span><br>          <span class="hljs-attr">description:</span> <span class="hljs-string">successful</span> <span class="hljs-string">operation</span><br>          <span class="hljs-attr">content:</span><br>            <span class="hljs-attr">application/json:</span><br>              <span class="hljs-attr">schema:</span><br>                <span class="hljs-attr">type:</span> <span class="hljs-string">object</span><br>                <span class="hljs-attr">example:</span><br>                  &#123;<br>                    <span class="hljs-string">&quot;code&quot;</span><span class="hljs-string">:20000</span>,<br>                    <span class="hljs-string">&quot;msg&quot;</span><span class="hljs-string">:&quot;user</span> <span class="hljs-string">login</span> <span class="hljs-string">success&quot;</span>,<br>                    <span class="hljs-string">&quot;token&quot;</span><span class="hljs-string">:&quot;qwertyuiop&quot;</span><br>                  &#125;<br>        <span class="hljs-attr">&#x27;404&#x27;:</span> <span class="hljs-comment">#返回404失败</span><br>          <span class="hljs-attr">description:</span> <span class="hljs-string">page</span> <span class="hljs-string">not</span> <span class="hljs-string">found</span> <br></code></pre></td></tr></table></figure><p><img src="/img/%E4%BD%BF%E7%94%A8yml%E6%96%87%E4%BB%B6%E6%9E%84%E5%BB%BAswagger%E6%96%87%E6%A1%A3/image-20210827102721799.png" alt="image-20210827102721799"></p><p>​    </p><p><strong>另一种参数方式</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">paths:</span><br>  <span class="hljs-string">/service-test/v1/get_self_info:</span><br>    <span class="hljs-attr">get:</span><br>      <span class="hljs-attr">tags:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">用户</span><br>      <span class="hljs-attr">summary:</span> <span class="hljs-string">获取用户个人信息</span><br>      <span class="hljs-attr">parameters:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">token</span><br>          <span class="hljs-attr">in:</span> <span class="hljs-string">header</span><br>          <span class="hljs-attr">description:</span> <span class="hljs-string">token</span><br>          <span class="hljs-attr">required:</span> <span class="hljs-literal">true</span><br>          <span class="hljs-attr">schema:</span><br>            <span class="hljs-attr">type:</span> <span class="hljs-string">string</span><br>      <span class="hljs-attr">responses:</span><br>        <span class="hljs-attr">&#x27;200&#x27;:</span><br>          <span class="hljs-attr">description:</span> <span class="hljs-string">successful</span> <span class="hljs-string">operation</span><br>          <span class="hljs-attr">content:</span><br>            <span class="hljs-attr">application/json:</span><br>              <span class="hljs-attr">schema:</span><br>                <span class="hljs-string">$ref:</span> <span class="hljs-string">&#x27;#/components/schemas/Info&#x27;</span> <span class="hljs-comment">#引用在definitions下定义的Info</span><br>        <span class="hljs-attr">&#x27;default&#x27;:</span> <span class="hljs-comment">#执行出错的处理</span><br>          <span class="hljs-attr">description:</span> <span class="hljs-string">请求失败</span><br>        <br><span class="hljs-attr">components:</span><br>  <span class="hljs-attr">schemas:</span><br>    <span class="hljs-attr">Info:</span><br>      <span class="hljs-attr">type:</span> <span class="hljs-string">object</span>  <span class="hljs-comment">#值类型</span><br>      <span class="hljs-attr">properties:</span> <span class="hljs-comment">#定义属性</span><br>        <span class="hljs-attr">id:</span> <span class="hljs-comment">#属性名</span><br>          <span class="hljs-attr">type:</span> <span class="hljs-string">integer</span><br>          <span class="hljs-attr">format:</span> <span class="hljs-string">int64</span><br>        <span class="hljs-attr">username:</span><br>          <span class="hljs-attr">type:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">age:</span><br>          <span class="hljs-attr">type:</span> <span class="hljs-string">integer</span><br>          <span class="hljs-attr">format:</span> <span class="hljs-string">int64</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E4%BD%BF%E7%94%A8yml%E6%96%87%E4%BB%B6%E6%9E%84%E5%BB%BAswagger%E6%96%87%E6%A1%A3/image-20210827112512970.png" alt="image-20210827112512970"></p><p><img src="/img/%E4%BD%BF%E7%94%A8yml%E6%96%87%E4%BB%B6%E6%9E%84%E5%BB%BAswagger%E6%96%87%E6%A1%A3/image-20210827112706658.png" alt="image-20210827112706658"></p><h1 id="开启Swagger"><a href="#开启Swagger" class="headerlink" title="开启Swagger"></a>开启Swagger</h1><p><strong>安装本地Swagger editor</strong></p><p>在 <a href="https://swagger.io/">https://swagger.io/</a>  官网上下载安装<code>Swagger editor</code>，解压后从<code>cmd</code>进入该文件解压路径，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">npm insatll -g <span class="hljs-comment">//使用npm之前需要安装node.js环境</span><br>npm satrt<br></code></pre></td></tr></table></figure><p>执行完后才<code>cmd</code>窗口上就会显示<code>Swagger</code>渲染前端页面的url，在浏览器中输入就可以进入本地<code>Swagger editor</code></p><p>​    </p><p><strong>在线使用Swagger editor</strong></p><p>内容和本地是一样的，有网络的情况下可以使用 <a href="http://editor.swagger.io/">http://editor.swagger.io/</a>  体验在线版</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上诉<code>swagger</code>的<code>yml</code>可以给前端一个简单明了的api接口文档，<strong>能大幅度提升项目整体开发进度</strong></p><p>本文只是使用了<code>yml</code>文档来构建<code>swagger</code>前端渲染文档，除此之外，还可以以通过使用给接口代码添加申明式注释的方式，将放在下次的文章内容中</p>]]></content>
    
    
    
    <tags>
      
      <tag>Swagger</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gin中添加限流中间件</title>
    <link href="/2021/10/15/Gin%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%99%90%E6%B5%81%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <url>/2021/10/15/Gin%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%99%90%E6%B5%81%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="限流概念"><a href="#限流概念" class="headerlink" title="限流概念"></a>限流概念</h1><p>高并发系统三大利器“缓存、降级、限流</p><ul><li>缓存：提升系统访问速度和增大处理容量，为相应业务增加缓存</li><li>降级：当服务器压力剧增时，根据业务策略降级，以释放服务资源保证业务正常</li><li>限流：通过对并发限速，以达到拒绝服务、排队或等待、降价等处理</li></ul><h1 id="限流策略"><a href="#限流策略" class="headerlink" title="限流策略"></a>限流策略</h1><blockquote><p><strong>漏桶限流：每次请求时计算桶流量，超过阈值则降级请求</strong></p></blockquote><p>有一个漏桶，请求来了就像是往漏桶里注入水，桶满了舍弃请求，但是无论来多少次请求，桶都以固定的速度滴水(处理请求)</p><p>因为无论来多少流量是以固定的速度处理请求，<strong>所以不能有效的处理大量突发请求的场景</strong></p><p><img src="/img/Gin%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%99%90%E6%B5%81%E4%B8%AD%E9%97%B4%E4%BB%B6/image-20210815095535338.png" alt="image-20210815095535338"></p><p>​    </p><blockquote><p><strong>令牌桶限流：每次请求时从令牌桶里取令牌，取不到则降级请</strong>求</p></blockquote><p>有一个令牌桶，以固定的速率向令牌桶中添加令牌，如果桶满了则丢弃令牌，每次请求来了就向令牌桶中取令牌，取得到就放行处理，令牌不足则拒绝请求</p><p><strong>因为令牌桶在平时处理请求时会保持一个桶中余留很多空闲令牌的状态，则可以处理大量突发请求的场景</strong></p><p><img src="/img/Gin%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%99%90%E6%B5%81%E4%B8%AD%E9%97%B4%E4%BB%B6/image-20210815095458830.png" alt="image-20210815095458830"></p><h1 id="限流库的使用"><a href="#限流库的使用" class="headerlink" title="限流库的使用"></a>限流库的使用</h1><p><strong>安装限流库</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> github.<span class="hljs-keyword">com</span>/juju/ratelimit<br></code></pre></td></tr></table></figure><p>​    </p><p><strong>创建令牌桶的方法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建指定填充速率和容量大小的令牌桶</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewBucket</span><span class="hljs-params">(fillInterval time.Duration, capacity <span class="hljs-keyword">int64</span>)</span> *<span class="hljs-title">Bucket</span></span><br><br><span class="hljs-comment">// 创建指定填充速率、容量大小和每次填充的令牌数的令牌桶</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewBucketWithQuantum</span><span class="hljs-params">(fillInterval time.Duration, capacity, quantum <span class="hljs-keyword">int64</span>)</span> *<span class="hljs-title">Bucket</span></span><br><br><span class="hljs-comment">// 创建填充速度为指定速率和容量大小的令牌桶</span><br><span class="hljs-comment">// NewBucketWithRate(0.1, 200) 表示每秒填充20个令牌</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewBucketWithRate</span><span class="hljs-params">(rate <span class="hljs-keyword">float64</span>, capacity <span class="hljs-keyword">int64</span>)</span> *<span class="hljs-title">Bucket</span></span><br></code></pre></td></tr></table></figure><p>​    </p><p><strong>取出令牌的方法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 取token（非阻塞）</span><br><span class="hljs-comment">// 输入取token的数量，返回时间</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tb *Bucket)</span> <span class="hljs-title">Take</span><span class="hljs-params">(count <span class="hljs-keyword">int64</span>)</span> <span class="hljs-title">time</span>.<span class="hljs-title">Duration</span></span><br><span class="hljs-comment">// 输入去token的数量，返回移除的令牌数，如果取不到token则返回0</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tb *Bucket)</span> <span class="hljs-title">TakeAvailable</span><span class="hljs-params">(count <span class="hljs-keyword">int64</span>)</span> <span class="hljs-title">int64</span></span><br><br><span class="hljs-comment">// 最多等maxWait时间取token</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tb *Bucket)</span> <span class="hljs-title">TakeMaxDuration</span><span class="hljs-params">(count <span class="hljs-keyword">int64</span>, maxWait time.Duration)</span> <span class="hljs-params">(time.Duration, <span class="hljs-keyword">bool</span>)</span></span><br><br><span class="hljs-comment">// 取token（阻塞）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tb *Bucket)</span> <span class="hljs-title">Wait</span><span class="hljs-params">(count <span class="hljs-keyword">int64</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tb *Bucket)</span> <span class="hljs-title">WaitMaxDuration</span><span class="hljs-params">(count <span class="hljs-keyword">int64</span>, maxWait time.Duration)</span> <span class="hljs-title">bool</span></span><br></code></pre></td></tr></table></figure><h1 id="Gin中使用限流中间件"><a href="#Gin中使用限流中间件" class="headerlink" title="Gin中使用限流中间件"></a>Gin中使用限流中间件</h1><p>在Gin中可以将限流作为中间件注册到路由中</p><p>既可以将它注册到全局中间件，也可以将它注册到局部的路由组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RateLimiter</span><span class="hljs-params">(fillTime time.Duration, <span class="hljs-built_in">cap</span> <span class="hljs-keyword">int64</span>)</span> <span class="hljs-title">gin</span>.<span class="hljs-title">HandlerFunc</span></span> &#123;<br>   <span class="hljs-comment">//指定令牌生产速度和容量</span><br>   bucket := ratelimit.NewBucket(fillTime, <span class="hljs-built_in">cap</span>)<br>   <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>       <span class="hljs-comment">// 取不到令牌则返回0</span><br>      <span class="hljs-keyword">if</span> bucket.TakeAvailable(<span class="hljs-number">1</span>) &lt; <span class="hljs-number">1</span> &#123;<br>         c.JSON(http.StatusOK, <span class="hljs-string">&quot;rate limit...&quot;</span>)<br>         c.Abort()<br>         <span class="hljs-keyword">return</span><br>      &#125;<br>      c.Next()<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker快速部署ELK</title>
    <link href="/2021/10/15/Docker%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2ELK/"/>
    <url>/2021/10/15/Docker%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2ELK/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为最近需要部署日志收集系统，而网上部署elk的方式多种多样，参差不齐，在尝试后总结出一种快速有效的部署方法</p><h1 id="ELK简介"><a href="#ELK简介" class="headerlink" title="ELK简介"></a>ELK简介</h1><p>ELK Stack是软件集合<code>Elasticsearch</code>、<code>Logstash</code>、<code>Kibana</code>的简称，由这三个软件及其相关的组件可以打造<strong>大规模日志实时处理系统</strong></p><ul><li><p><strong>Elasticsearch</strong> 是一个基于 Lucene 的、支持全文索引的分布式存储和索引引擎，<strong>主要负责将日志索引并存储起来，方便业务方检索查询</strong></p></li><li><p><strong>Logstash</strong>是一个<strong>日志收集、过滤、转发的中间件</strong>，主要负责将各条业务线的各类日志统一收集、过滤后，转发给 Elasticsearch 进行下一步处理</p></li><li><p><strong>Kibana</strong>是一个可视化工具，主要负责<strong>查询 Elasticsearch 的数据并以可视化的方式展现给业务方</strong>，比如各类饼图、直方图、区域图等</p></li></ul><h1 id="Docker部署"><a href="#Docker部署" class="headerlink" title="Docker部署"></a>Docker部署</h1><p>最好使用<strong>4G内存</strong>和<strong>40G磁盘</strong>的服务器，是在没有可以暂时使用虚拟机进行实验</p><p>​    </p><blockquote><p>创建容器之间的通信网络</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">docker network create docker_elk_test<br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>拉取镜像</p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull docker.elastic.co/elasticsearch/elasticsearch:<span class="hljs-number">7</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">docker</span> pull docker.elastic.co/kibana/kibana:<span class="hljs-number">7</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">docker</span> pull docker.elastic.co/logstash/logstash:<span class="hljs-number">7</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>​    </p><h2 id="部署elasticsearch"><a href="#部署elasticsearch" class="headerlink" title="部署elasticsearch"></a>部署elasticsearch</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">创建配置文件，文件位置可有自己选择<br>mkdir /usr/elk/elastic<br>cd /usr/elk/elastic<br>vim elasticsearch.yml<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">cluster.name: &quot;docker-cluster&quot;<br><span class="hljs-meta">#</span><span class="bash">配置elasticsearch远程访问</span><br>network.host: 0.0.0.0<br><span class="hljs-meta">#</span><span class="bash">不允许es根据磁盘情况来分配shard 防止磁盘不够时不能写数据</span><br><span class="hljs-meta">#</span><span class="bash">cluster.routing.allocation.disk.threshold_enabled: <span class="hljs-literal">false</span></span><br><span class="hljs-meta">#</span><span class="bash">磁盘占有率达到99%时将不允许往es写数据，只能读数据 默认95%</span><br><span class="hljs-meta">#</span><span class="bash">cluster.routing.allocation.disk.watermark.flood_stage: 99%</span><br></code></pre></td></tr></table></figure><p>​    </p><p><strong>docker 部署</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it -d --name es_test -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot; -p 9200:9200 -p 9300:9300 -v /usr/elk/elastic/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml --network docker_elk_test -e &quot;discovery.type=single-node&quot; docker.elastic.co/elasticsearch/elasticsearch:7.3.0<br></code></pre></td></tr></table></figure><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 指定jjvm运行参数 最大最小内存</span><br>-e ES_JAVA_OPTS=<span class="hljs-string">&quot;-Xms256m -Xmx256m&quot;</span> <br><span class="hljs-meta"># 指定通信网络</span><br>--network docker_elk_test<br><span class="hljs-meta"># 指定单节点部署</span><br>-e <span class="hljs-string">&quot;discovery.type=single-node&quot;</span><br></code></pre></td></tr></table></figure><p>启动后在本机上查看 <strong>localhost:9200</strong> </p><p><img src="/img/Docker%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2ELK/image-20211015092848637.png" alt="image-20211015092848637"></p><h2 id="部署kibana"><a href="#部署kibana" class="headerlink" title="部署kibana"></a>部署kibana</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /usr/elk/kibana<br>cd /usr/elk/kibana<br>vim kibana.yml<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">server.name: kibana<br><span class="hljs-meta">#</span><span class="bash"> 配置Kibana的远程访问</span><br>server.host: &quot;0.0.0.0&quot;<br><span class="hljs-meta">#</span><span class="bash"> 配置es访问地址</span><br>elasticsearch.hosts: [ &quot;http://xx.xx.xx.xx:9200&quot; ]<br><span class="hljs-meta">#</span><span class="bash"> 汉化界面</span><br>i18n.locale: &quot;zh-CN&quot;<br>xpack.monitoring.ui.container.elasticsearch.enabled: true<br></code></pre></td></tr></table></figure><p>​    </p><p><strong>docker 部署</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it -d -p 5601:5601  -v /usr/elk/kibana/kibana.yml:/usr/share/kibana/config/kibana.yml -v /etc/localtime:/etc/localtime -e ELASTICSEARCH_URL=http://xx.xx.xx.xx:9200 --network=docker_elk_test --name kibana_test docker.elastic.co/kibana/kibana:7.3.0<br></code></pre></td></tr></table></figure><p>启动后本子查看 <strong>localhost:5601</strong></p><p><img src="/img/Docker%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2ELK/image-20211015093911524.png" alt="image-20211015093911524"></p><h2 id="部署logstash"><a href="#部署logstash" class="headerlink" title="部署logstash"></a>部署logstash</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /usr/elk/logstash/config<br>cd /usr/elk/logstash/config<br>vim logstash.yml<br>mkdir /usr/elk/logstash/pipeline<br>cd /usr/elk/logstash/pipeline<br>vim logstash.conf<br></code></pre></td></tr></table></figure><p><strong>logstash.yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 配置logstash远程访问</span><br><span class="hljs-attr">http.host:</span> <span class="hljs-string">&quot;0.0.0.0&quot;</span><br><span class="hljs-comment"># 配置es访问地址</span><br><span class="hljs-attr">xpack.monitoring.elasticsearch.hosts:</span> [ <span class="hljs-string">&quot;http://xx.xx.xx.xx:9200&quot;</span> ]<br></code></pre></td></tr></table></figure><p><strong>logstash.conf</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sh">input &#123;<br>  file &#123;<br>    <span class="hljs-built_in">type</span> =&gt; <span class="hljs-string">&quot;systemlog-localhost&quot;</span><br>    <span class="hljs-comment">#指定文件采集路径</span><br>    path =&gt; <span class="hljs-string">&quot;/var/log/game/*.log&quot;</span><br>    <span class="hljs-comment">#指定收集json格式</span><br>    codec =&gt; json &#123;<br>       charset =&gt; <span class="hljs-string">&quot;UTF-8&quot;</span><br>    &#125;<br>    <span class="hljs-comment">#开始收集点</span><br>    start_position =&gt; <span class="hljs-string">&quot;beginning&quot;</span><br>    <span class="hljs-comment">#扫描间隔时间，默认是1s，建议5s</span><br>    stat_interval =&gt; <span class="hljs-string">&quot;5&quot;</span><br>  &#125;<br>&#125;<br><br>output &#123;<br>  elasticsearch &#123;<br>    hosts =&gt; [<span class="hljs-string">&quot;xx.xx.xx.xx:9200&quot;</span>]<br>    <span class="hljs-comment"># 指定输出es的index</span><br>    index =&gt; <span class="hljs-string">&quot;game_test&quot;</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><p><strong>docker部署</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it -d --name logstash_test --network=docker_elk_test -p 5000:5000 -v /usr/elk/logstash/config/logstash.yml:/usr/share/logstash/config/logstash.yml -v /usr/elk/logstash/pipeline/logstash.conf:/usr/share/logstash/pipeline/logstash.conf -v /usr/log/game:/var/log/game docker.elastic.co/logstash/logstash:7.3.0 <br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 一定要指明收集地址，上面配置文件的路径是容器内部的，一定要建立与外部的数据卷</span><br>-v /usr/<span class="hljs-built_in">log</span>/game:/var/<span class="hljs-built_in">log</span>/game<br></code></pre></td></tr></table></figure><p>现在在文件 <strong>/usr/log/game/xxx.log</strong> 在kibana创建索引index后就可以查看</p><p><img src="/img/Docker%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2ELK/image-20211015094607601.png" alt="image-20211015094607601"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上文只是<code>elk</code>的初步部署方式</p><p>在<code>logstash</code>中还有很多采集日志的小技巧，特别是<code>grok</code>中的正则</p><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-inputs-file.html#plugins-inputs-file-sincedb_path">logstash官网</a> 中可以进一步查看相应内容</p>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go逃逸分析</title>
    <link href="/2021/10/15/Go%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/"/>
    <url>/2021/10/15/Go%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在优化公司之前实习生写的后端代码，在db层这里</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateXxx</span><span class="hljs-params">(xx *model.Xxx)</span> <span class="hljs-title">error</span></span> &#123;<br>   <span class="hljs-keyword">return</span> db.Database.Create(&amp;xx).Error<br>&#125;<br></code></pre></td></tr></table></figure><p>当时觉得只是创建，则不需要传结构体指针，并且觉得传了指针后引起内存逃逸，增加GC压力，后续中总觉得是传指针可能不一定就会引发内存逃逸，则查阅了相关资料和自己之前做的笔记，对此情况做一个详细的说明</p><h1 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h1><p>Go有两个地方可以分配内存：一个全局堆空间用来<strong>动态分配内存</strong> (<strong>new  make</strong>)，另一个是每个goroutine都有的自身栈空间(<strong>初始是2k</strong>)</p><p><img src="/img/Go%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/image-20210801171749935.png" alt="image-20210801171749935"></p><blockquote><p>栈</p></blockquote><p>栈区内存一般由<strong>编译器自动进行分配和释放</strong>，其中存储着函数的入参以及局部变量，这些参数会<strong>随着函数的创建而创建，函数的返回而销毁</strong>（通过<code>CPU push &amp; release</code> ）</p><p>​    </p><blockquote><p>堆</p></blockquote><p>堆区的内存一般由<strong>编译器和工程师自己共同进行管理分配</strong>，交给 <strong>Runtime GC</strong> 来释放。堆上分配必须找到一块足够大的内存来存放新的变量数据。后续释放时，垃圾回收器扫描空间寻找不再被使用的对象</p><p>任何时候一个值出了一个函数的作用域，它就会被自动分配到堆上 (<strong>由编译器分析</strong>出来是否有<strong>逃逸行为</strong>)</p><p>​    </p><p><strong>栈分配廉价，堆分配昂贵</strong></p><p>Go声明语法并没有提到栈和堆，而是交给GO编译器决定在哪分配内存，保证程序的正确性</p><h1 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h1><p>通过检查变量的作用域是否超出它所在的栈来决定是否将它分配在堆上的技术，其中<strong>变量的作用域超出它所在的栈这种行为即被称为逃逸</strong>。逃逸分析在大多数语言里属于静态分析：在编译期由静态代码分析来决定一个值是否能被分配在栈帧上，还是需要逃逸到堆上</p><ul><li>减少GC压力，栈的变量，随着函数退出后系统直接回收，不需要标记后清除</li><li>减少内存碎片的产生</li><li>减轻分配堆内存的开销，提高程序的运行速度</li></ul><p>​    </p><p>Go语言虽然没有明确说明逃逸分析规则，但是有以下几点准则，是可以参考的</p><ul><li>逃逸分析是在编译器完成的，这是不同于jvm的运行时逃逸分析</li><li>如果变量在函数外部没有引用，则优先放到栈中</li><li>如果变量在函数<strong>外部存在引用</strong>，则<strong>必定放在堆中</strong></li></ul><p>​    </p><p>可以通过 <code>go build -gcflags -m xxx.go</code> 命令来查看逃逸分析结果，其中<code>-m </code>打印逃逸分析信息</p><h1 id="逃逸案例"><a href="#逃逸案例" class="headerlink" title="逃逸案例"></a>逃逸案例</h1><blockquote><p>变量类型不确定</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">666</span><br>fmt.Println(a)<br>&#125;<br></code></pre></td></tr></table></figure><p>因为<code>fmt.Println</code>的函数参数为<code>interface</code>类型，编译期不能确定其参数的具体类型，所以将其分配于堆上</p><p>​    </p><blockquote><p>暴露给外部指针</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> *<span class="hljs-title">int</span></span> &#123;<br>a := <span class="hljs-number">666</span><br><span class="hljs-keyword">return</span> &amp;a<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> num *<span class="hljs-keyword">int</span><br>num= foo()<br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>变量所占内存较大</p></blockquote><p>Go中常说的<code>goroutine</code>初始大小为<code>2KB</code>，就是指用户栈，而堆则会大很多，所以，为了不造成栈溢出和频繁的扩缩容，<strong>大的对象分配在堆上更加合理</strong></p><p>​    </p><blockquote><p>变量大小不确定</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>n := <span class="hljs-number">1</span><br>s := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>s[i] = i<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>foo()<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>make</code>方法中，没有直接指定大小，而是填入了变量<code>n</code>，这时Go逃逸分析也会将其分配到堆区去。可见，为了保证内存的绝对安全，Go的编译器可能会将一些变量不合时宜地分配到堆上</p><p>​    </p><blockquote><p>发送指针或带有指针的值到channel中</p></blockquote><p>在编译时，是没有办法知道哪个 <code>goroutine</code> 会在 <code>channel</code> 上接收数据。所以编译器没法知道变量什么时候才会被释放</p><p>​    </p><blockquote><p>在一个切片上存储或带有指针的值</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> s []*Student<br>   s=<span class="hljs-built_in">append</span>(s,&amp;Student&#123;Name: <span class="hljs-string">&quot;ice&quot;</span>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>一个典型的例子就是 <code>[]*string</code>。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上</p><p>​    </p><blockquote><p>slice背后的数组被重新分配 (地址要改变)</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//发生了逃逸 因为底层数组扩容数组会重新分配</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddNum</span><span class="hljs-params">(a *[]<span class="hljs-keyword">int</span>)</span></span>&#123;<br>   *a=<span class="hljs-built_in">append</span>(*a,<span class="hljs-number">99</span>)<br>&#125;<br><span class="hljs-comment">//没有发生逃逸 因为没有扩容底层数组没有改变</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UpdateNum</span><span class="hljs-params">(a *[]<span class="hljs-keyword">int</span>)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(*a) &gt; <span class="hljs-number">0</span> &#123;<br>(*a)[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考之前 <a href="https://snowyangyuxin.github.io/2021/07/29/Go%E5%88%87%E7%89%87%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E4%BC%A0%E9%80%92/">Go切片在函数中的传递</a>知，在切片作为参数传递时，如果append引发扩容就会<strong>重新分配底层数组的地址</strong></p><p>slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配</p><p>​    </p><blockquote><p>在interface类型上调用方法</p></blockquote><p>在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道</p><p>​    </p><blockquote><p>外部是否发生引用</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> global *<span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> x <span class="hljs-keyword">int</span><br>x = <span class="hljs-number">1</span><br>global = &amp;x<br>&#125;<br></code></pre></td></tr></table></figure><p>函数里的<code>x</code>变量在堆上分配，因为它在函数退出后依然可以通过<code>global</code>变量找到，虽然它是在函数内部定义的</p><h1 id="指针逃逸的总结"><a href="#指针逃逸的总结" class="headerlink" title="指针逃逸的总结"></a>指针逃逸的总结</h1><blockquote><p>指针必然发生逃逸的三种情况</p></blockquote><ul><li><p>在某个函数中<code>new</code>或字面量创建出的变量，将其指针作为函数返回值，则该变量一定发生逃逸（构造函数返回的指针变量一定逃逸）</p></li><li><p>被已经逃逸的变量引用的指针，一定发生逃逸</p></li><li><p>被指针类型的<code>slice、map和chan</code>引用的指针，一定发生逃逸</p></li></ul><p>​    </p><blockquote><p>指针必然不会逃逸的情况</p></blockquote><ul><li><p>指针被未发生逃逸的变量引用；</p></li><li><p>仅仅在函数内对变量做取址操作，而未将指针传出；</p></li></ul><p>​    </p><blockquote><p>指针有一些情况可能发生逃逸，也可能不会发生逃逸</p></blockquote><ul><li>将指针作为入参传给别的函数；这里还是要看指针在被传入的函数中的处理过程，如果发生了上边的三种情况，则会逃逸；否则不会逃逸</li></ul><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><ul><li><p>现在说明在函数传参传指针不应定会发生内存逃逸，要结合实际情况，看函数中是否将参数传入<code>interface</code>参数的函数中等</p></li><li><p>理解逃逸分析一定能帮助写出更好的程序。知道变量分配在栈堆之上的差别，那么我们就要尽量写出分配在栈上的代码，堆上的变量变少了，可以减轻内存分配的开销，减小gc的压力，提高程序的运行速度</p></li><li><p>不要盲目使用变量的指针作为函数参数，虽然它会减少复制操作。但其实当参数为变量自身的时候，复制是在栈上完成的操作，开销远比变量逃逸后动态地在堆上分配内存少的多 (可能会发生逃逸)</p></li><li><p>尽量写出少一些逃逸的代码，提升程序的运行效率</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go调用K8S</title>
    <link href="/2021/09/26/Go_k8s/"/>
    <url>/2021/09/26/Go_k8s/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用Go创建k8s的客户端和k8s API server进行交互是非常简便的，本文将进行简要的讲解</p><h1 id="拉取依赖"><a href="#拉取依赖" class="headerlink" title="拉取依赖"></a>拉取依赖</h1><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">go</span> get k<span class="hljs-number">8</span>s.io/client-go@v<span class="hljs-number">0</span>.<span class="hljs-number">18</span>.<span class="hljs-number">11</span>-rc.<span class="hljs-number">0</span><br><span class="hljs-attribute">go</span> get k<span class="hljs-number">8</span>s.io/api@v<span class="hljs-number">0</span>.<span class="hljs-number">18</span>.<span class="hljs-number">11</span>-rc.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h1 id="创建客户端"><a href="#创建客户端" class="headerlink" title="创建客户端"></a>创建客户端</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>   server = <span class="hljs-string">&quot;https://127.0.0.1:8080&quot;</span><br>   token  = <span class="hljs-string">&quot;xxxx&quot;</span><br>)<br><span class="hljs-keyword">var</span>(<br>Client *kubernetes.Clientset<br>)<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitK8sClient</span><span class="hljs-params">()</span> *<span class="hljs-title">kubernetes</span>.<span class="hljs-title">Clientset</span></span> &#123;<br>   tokenBytes, err := base64.StdEncoding.DecodeString(token) <span class="hljs-comment">// 解析token</span><br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;token 解析失败&quot;</span>)<br>   &#125;<br>   config := &amp;rest.Config&#123;<br>      BearerToken: <span class="hljs-keyword">string</span>(tokenBytes), <span class="hljs-comment">// k8s的token</span><br>      Host:        server, <span class="hljs-comment">// k8s的host</span><br>      TLSClientConfig: rest.TLSClientConfig&#123;<br>         Insecure: <span class="hljs-literal">true</span>,<br>      &#125;,<br>   &#125;<br>   <span class="hljs-comment">// 根据指定的 config 创建一个新的 clientSet</span><br>   clientSet, err := kubernetes.NewForConfig(config)<br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-built_in">panic</span>(err.Error())<br>   &#125;<br>   <span class="hljs-keyword">return</span> clientSet<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="获取deployment"><a href="#获取deployment" class="headerlink" title="获取deployment"></a>获取deployment</h1><h2 id="使用API获取deployment"><a href="#使用API获取deployment" class="headerlink" title="使用API获取deployment"></a>使用API获取deployment</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 获取deployment</span><br><span class="hljs-comment">// 指定namespace为test_namespace</span><br>deployments, err := Client.AppsV1().Deployments(<span class="hljs-string">&quot;test_namespace&quot;</span>).List(context.TODO(), meta_v1.ListOptions&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>   <span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> deployments.Items &#123;<br>   fmt.Println(v.Name)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用informer获取deployment"><a href="#使用informer获取deployment" class="headerlink" title="使用informer获取deployment"></a>使用informer获取deployment</h2><p><strong>informer</strong></p><blockquote><p><strong>为什么使用informer？</strong></p></blockquote><p>使用 Informer 实例的 Lister() 方法， List/Get Kubernetes 中的 Object 时，<strong>Informer 不会去请求 Kubernetes API，而是直接查找缓存在本地内存中的数据(这份数据由 Informer 自己维护)<strong>。通过这种方式，</strong>Informer 既可以更快地返回结果，又能减少对 Kubernetes API 的直接调用</strong>。</p><p>​    </p><blockquote><p><strong>informer的机制</strong></p></blockquote><p>Informer 只会调用 Kubernetes List 和 Watch 两种类型的 API。Informer 在初始化的时，<strong>先调用 Kubernetes List API 获得某种 resource 的全部 Object，缓存在内存中</strong>; 然后，调用 Watch API 去 watch 这种 resource，去维护这份缓存; 最后，Informer 就不再调用 Kubernetes 的任何 API。</p><p>​    </p><blockquote><p><strong>可监听并触发回调函数</strong></p></blockquote><p>Informer 通过 Kubernetes Watch API 监听某种 resource 下的所有事件。而且，Informer 可以添加自定义的<strong>回调函数</strong>，这个回调函数实例(即 <code>ResourceEventHandler</code> 实例)只需实现 <code>OnAdd(obj interface&#123;&#125;)</code>、<code>OnUpdate(oldObj, newObj interface&#123;&#125;)</code>和 <code>OnDelete(obj interface&#123;&#125;)</code> 三个方法，这三个方法分别对应 informer 监听到创建、更新和删除这三种事件类型。</p><p>​    </p><blockquote><p><strong>二级缓存</strong></p></blockquote><p>二级缓存属于 Informer 的底层缓存机制，这两级缓存分别是 <strong>DeltaFIFO</strong> 和 <strong>LocalStore</strong>。</p><p>Delta代表变化， FIFO则是先入先出的队列。DeltaFIFO将接受来的资源event，转化为特定的变化类型，存储在队列中，周期性的POP出去，分发到事件处理器，并更新Indexer中的本地缓存</p><p>这两级缓存的用途各不相同。DeltaFIFO 用来存储 Watch API 返回的各种事件 ，LocalStore 只会被 Lister 的 List/Get 方法访问 。</p><p>虽然 Informer 和 Kubernetes 之间没有 resync 机制，但 Informer 内部的这两级缓存之间存在 resync 机制。</p><p>​    </p><blockquote><p><strong>详细参考资料</strong></p></blockquote><p><a href="https://www.kubernetes.org.cn/2693.html">informer详解1</a></p><p><a href="https://www.cnblogs.com/yangyuliufeng/p/13611126.html">informer详解2</a></p><p>​    </p><p><strong>goalng中使用</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> DeploymentInformer cache.SharedIndexInformer<br><br>stop := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-comment">//创建factory，第一个参数是与k8s-api-server交互的客户端，第二个参数用于设置多久进行一次resync(周期性的List操作)</span><br>factory := informers.NewSharedInformerFactoryWithOptions(Client, time.Second*<span class="hljs-number">10</span>) <br>DeploymentInformer = factory.Apps().V1().Deployments().Informer() <span class="hljs-comment">// 创建deployment的informer</span><br><br><span class="hljs-comment">//通过informer.Run(stop)运行该informer，它是一个持久化的goroutine，通过client对象与k8s-api-server交互。</span><br><span class="hljs-comment">//chan_stop用于在程序进程退出前通知Informer退出</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>DeploymentInformer.Run(stop) <br>&#125;()<br><br><span class="hljs-comment">//需要先运行informer监听后才能获取列表</span><br>list := DeploymentInformer.GetStore().List()<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> list &#123;<br>deployment := v.(*apps_v1.Deployment)<br>fmt.Println(deployment.Name)<br>&#125;<br><span class="hljs-keyword">select</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h1 id="创建deployment"><a href="#创建deployment" class="headerlink" title="创建deployment"></a>创建deployment</h1><p>说明</p><blockquote><p>label</p></blockquote><p>Label是Kubernetes系列中另外一个核心概念。是一组绑定到K8s资源对象上的key/value对。同一个对象的labels属性的key必须唯一。label可以附加到各种资源对象上，如Node,Pod,Service,RC等。</p><p>通过给指定的资源对象捆绑一个或多个不用的label来实现<strong>多维度的资源分组管理功能</strong>，以便于灵活，<strong>方便地进行资源分配，调度，配置，部署等管理工作</strong>。</p><p>示例如下：　</p><ul><li>版本标签：”release” : “stable” , “release” : “canary”…</li><li>环境标签：”environment” : “dev” , “environment” : “production”</li><li>架构标签：”tier” : “frontend” , “tier” : “backend” , “tier” : “middleware”</li><li>分区标签：”partition” : “customerA” , “partition” : “customerB”…</li><li>质量管控标签：”track” : “daily” , “track” : “weekly”</li></ul><p>​    </p><blockquote><p>namespace</p></blockquote><p>​       namespaces是kubernetes集群中的虚拟化集群。在一个Kubernetes集群中可以拥有多个命名空间，<strong>它们在逻辑上彼此隔离</strong>。 他们可以为个人和团队提供组织，安全甚至性能方面的帮助。</p><p>​        命名空间适用于存在很多跨多个团队或项目的用户的场景。对于只有几到几十个用户的集群，根本不需要创建或考虑命名空间。当需要名称空间提供的功能时，请开始使用它们。<br> 命名空间为名称提供了一个范围。资源的名称需要在命名空间内是唯一的，但不能跨命名空间。命名空间不能相互嵌套，<strong>每个 Kubernetes 资源只能在一个命名空间中</strong>。<br>​        命名空间是在<strong>多个用户之间划分集群资源的一种方法</strong>（通过资源配额）。<br>​        在 Kubernetes 未来版本中，相同命名空间中的对象默认将具有相同的访问控制策略。<br>​        不需要使用多个命名空间来分隔轻微不同的资源，例如同一软件的不同版本：<strong>使用 labels来区分同一命名空间中的不同资源</strong>。</p><p>​    </p><blockquote><p>selector</p></blockquote><p>K8S中的Service是一个抽象概念，它定义了一个服务的多个pod逻辑合集和访问pod的策略，一般把service称为微服务</p><p><strong>举个例子：</strong>一个a服务运行3个pod，b服务怎么访问a服务的pod，pod的ip都不是持久化的<strong>重启之后就会有变化</strong>。<br>这时候b服务可以访问跟a服务绑定的service，service信息是固定的提前告诉b就行了，service通过Label Selector跟a服务的pod绑定,无论a的pod如何变化对b来说都是透明的。</p><p>​    </p><blockquote><p>ImagePullPolicy</p></blockquote><ul><li>Allow：总是拉取pull</li><li>ifNotPresent：本地有镜像则优先使用本地</li><li>Never：只是用本地镜像，从不拉取</li></ul><p><strong>代码内书写yaml进行创建</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateDeployment</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br>    <br>deployment := &amp;apps_v1.Deployment&#123;<br>ObjectMeta: meta_v1.ObjectMeta&#123;<br>Name: <span class="hljs-string">&quot;xxx-name&quot;</span>,<br>&#125;,<br>Spec: apps_v1.DeploymentSpec&#123;<br>Replicas: int32Ptr(<span class="hljs-number">2</span>),<br>Selector: &amp;meta_v1.LabelSelector&#123;<br>MatchLabels: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>&#123;<br><span class="hljs-string">&quot;app&quot;</span>: <span class="hljs-string">&quot;xxx-name&quot;</span>,<br>&#125;,<br>&#125;,<br>Template: core_v1.PodTemplateSpec&#123;<br>ObjectMeta: meta_v1.ObjectMeta&#123;<br>Labels: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>&#123;<br><span class="hljs-string">&quot;app&quot;</span>: <span class="hljs-string">&quot;xxx-name&quot;</span>,<br>&#125;,<br>&#125;,<br>Spec: core_v1.PodSpec&#123;<br>Containers: []core_v1.Container&#123;<br>&#123;<br>Name:            <span class="hljs-string">&quot;test-a&quot;</span>,<br>Image:           <span class="hljs-string">&quot;image_a:1.1.0&quot;</span>,<br>ImagePullPolicy: <span class="hljs-string">&quot;IfNotPresent&quot;</span>,<br>Ports: []core_v1.ContainerPort&#123;<br>&#123;<br>Name:          <span class="hljs-string">&quot;http&quot;</span>,<br>Protocol:      core_v1.ProtocolTCP,<br>ContainerPort: <span class="hljs-number">8080</span>,<br>&#125;,<br>&#125;,<br>&#125;,<br>&#123;<br>                            Name:            <span class="hljs-string">&quot;test-b&quot;</span>,<br>Image:           <span class="hljs-string">&quot;image_b:1.1.0&quot;</span>,<br>ImagePullPolicy: <span class="hljs-string">&quot;IfNotPresent&quot;</span>,<br>Ports: []core_v1.ContainerPort&#123;<br>&#123;<br>Name:          <span class="hljs-string">&quot;http&quot;</span>,<br>Protocol:      core_v1.ProtocolTCP,<br>ContainerPort: <span class="hljs-number">8081</span>,<br>&#125;,<br>&#125;,<br>&#125;,<br>&#125;,<br>&#125;,<br>&#125;,<br>&#125;,<br>&#125;<br>    <span class="hljs-comment">// 创建deployment</span><br>    <span class="hljs-comment">// 指定namespace为test_namespace</span><br><span class="hljs-keyword">if</span> _, err := Client.AppsV1().Deployments(<span class="hljs-string">&quot;test_namespace&quot;</span>).Create(context.TODO(), deployment, meta_v1.CreateOptions&#123;&#125;); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">int32Ptr</span><span class="hljs-params">(i <span class="hljs-keyword">int32</span>)</span> *<span class="hljs-title">int32</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;i<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="获取configmap"><a href="#获取configmap" class="headerlink" title="获取configmap"></a>获取configmap</h1><p>ConfigMap是一种API对象，用来将<strong>非加密数据</strong>保存到键值对中。可以用作环境变量、命令行参数或者存储卷中的配置文件。</p><p>ConfigMap可以将环境变量<strong>配置信息和容器镜像解耦</strong>，便于应用配置的修改。如果需要存储加密信息时可以使用Secret对象</p><p><a href="https://liumiaocn.blog.csdn.net/article/details/103818799?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.no_search_link">k8s中configmap的增删查改</a></p><p>​    </p><p><strong>golang中使用</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">data, err := Client.CoreV1().ConfigMaps(<span class="hljs-string">&quot;namespace_name&quot;</span>).Get(context.TODO(), <span class="hljs-string">&quot;configmap_name&quot;</span>, meta_v1.GetOptions&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">for</span> key,value:=<span class="hljs-keyword">range</span> data.Data&#123;<br>fmt.Println(key,<span class="hljs-string">&quot;:&quot;</span>,value)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go使用copier库</title>
    <link href="/2021/09/24/Go_copier%E5%BA%93/"/>
    <url>/2021/09/24/Go_copier%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在重构公司项目的<code>model</code>层，发现在数据库<code>model</code>向返回<code>ack  model</code>之间的结构体转换时，因为<code>model</code>字段多，则存在大量的直接赋值，不美观也不优雅，例如</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(person *Person)</span> <span class="hljs-title">MapTo</span><span class="hljs-params">()</span> <span class="hljs-title">model</span>.<span class="hljs-title">Student</span></span> &#123;<br>    <span class="hljs-keyword">var</span> student model.Student<br>now := time.Now()<br>    student.ID=person.ID<br>    student.Name=persobn.Name<br>    student.Age=persobn.Age<br>    student.Phone=persobn.Phone<br>    student.Address=persobn.Address<br>    student.Gender=persobn.Gender<br>    student.ParentPhone=persobn.ParentPhone<br>    student.Mother=persobn.Mother<br>    student.Father=persobn.Father<br>    student.Socre=<span class="hljs-number">100</span><br><span class="hljs-keyword">return</span> studnet<br>&#125;<br></code></pre></td></tr></table></figure><p>而使用Go的copier库可以<strong>完成不同类型结构体相同字段的赋值</strong>，并且还可以<strong>完成不同字段的赋值</strong>，下面将进行简单的演示</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go get github.com/jinzhu/copier<br></code></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><blockquote><p><strong>字段名相同，类型相同</strong></p></blockquote><p>对于不同类型的结构体，如果字段名相同且字段类型相同，那么<code>copier</code>就会对该字段直接赋值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>   ID      <span class="hljs-keyword">int</span><br>   Name    <span class="hljs-keyword">string</span><br>   Age     <span class="hljs-keyword">int</span><br>   Address <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>   ID      <span class="hljs-keyword">int</span><br>   Name    <span class="hljs-keyword">string</span><br>   Age     <span class="hljs-keyword">int</span><br>   Address <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   person := Person&#123;<br>      ID:      <span class="hljs-number">1</span>,<br>      Name:    <span class="hljs-string">&quot;snow&quot;</span>,<br>      Age:     <span class="hljs-number">22</span>,<br>      Address: <span class="hljs-string">&quot;China&quot;</span>,<br>   &#125;<br>   <span class="hljs-keyword">var</span> student Student<br>   copier.Copy(&amp;student, &amp;person)<br>   fmt.Println(student)<br>&#125;<br><span class="hljs-comment">//&#123;1 snow 22 China&#125;</span><br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p><strong>字段名相同，类型不同</strong></p></blockquote><p>对于这种情况<code>copie</code>r是不会赋值的，则需要自己手动配置 (所以在model 和 ack间尽量不要设置字段名相同而类型不同)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>   ID      <span class="hljs-keyword">int</span><br>   Name    <span class="hljs-keyword">string</span><br>   Age     <span class="hljs-keyword">int</span><br>   Parent  []<span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>   ID     <span class="hljs-keyword">int</span><br>   Name   <span class="hljs-keyword">string</span><br>   Age    <span class="hljs-keyword">int</span><br>   Parent <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   person := Person&#123;<br>      ID:      <span class="hljs-number">1</span>,<br>      Name:    <span class="hljs-string">&quot;snow&quot;</span>,<br>      Age:     <span class="hljs-number">22</span>,<br>      Parent:  []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;mother&quot;</span>, <span class="hljs-string">&quot;father&quot;</span>&#125;,<br>   &#125;<br>   <span class="hljs-keyword">var</span> student Student<br>   copier.Copy(&amp;student, &amp;person)<br>   student.Parent=strings.Join(person.Parent,<span class="hljs-string">&quot;,&quot;</span>) <span class="hljs-comment">//这里需要手动配置</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p><strong>目标对象中出现不同字段名，但与源对象字段相关</strong></p></blockquote><p>有时候源对象某个字段没有出现在目标对象中，但是目标对象可以使用一个相同字段名的方法，方法接收相同类型的参数，这样在<code>copier</code> <code>Copy</code>时会以源对象的这个字段作为参数调用目标对象的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>   ID     <span class="hljs-keyword">int</span><br>   Name   <span class="hljs-keyword">string</span><br>   Age    <span class="hljs-keyword">int</span><br>   Nation <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>   ID      <span class="hljs-keyword">int</span><br>   Name    <span class="hljs-keyword">string</span><br>   Age     <span class="hljs-keyword">int</span><br>   Address <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(student *Student)</span> <span class="hljs-title">Nation</span><span class="hljs-params">(nat <span class="hljs-keyword">string</span>)</span></span> &#123; <span class="hljs-comment">//以源对象字段名相同的目标对象方法</span><br>   student.Address=nat+<span class="hljs-string">&quot;BeiJin&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   person := Person&#123;<br>      ID:     <span class="hljs-number">1</span>,<br>      Name:   <span class="hljs-string">&quot;snow&quot;</span>,<br>      Age:    <span class="hljs-number">22</span>,<br>      Nation: <span class="hljs-string">&quot;China&quot;</span>,<br>   &#125;<br>   <span class="hljs-keyword">var</span> student Student<br>   copier.Copy(&amp;student, &amp;person)<br>   fmt.Println(student)<br>&#125;<br><span class="hljs-comment">//&#123;1 snow 22 ChinaBeiJin&#125;</span><br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>目标对象中出现不同字段名，但与源对象字段无关</p></blockquote><p>对于这种情况就和<strong>字段名相同类型不同</strong>的方法一样，需要对这个字段单独处理</p><p>​    </p><blockquote><p>不同类型切片的赋值</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   persons := []Person&#123;<br>      &#123;ID: <span class="hljs-number">1</span>, Name: <span class="hljs-string">&quot;snow&quot;</span>,Age: <span class="hljs-number">22</span>&#125;,<br>      &#123;ID: <span class="hljs-number">2</span>, Name: <span class="hljs-string">&quot;ice&quot;</span>,Age: <span class="hljs-number">18</span>&#125;,<br>   &#125;<br>   <span class="hljs-keyword">var</span> students []Student<br>   copier.Copy(&amp;students, &amp;persons)<br>   fmt.Println(students)<br>&#125;<br><span class="hljs-comment">//[&#123;1 snow 22&#125; &#123;2 ice 18&#125;]</span><br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>结构体复制到切片</p></blockquote><p>根据源对象生成一个和目标切片类型相符合的对象，然后<code>append</code>到目标切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   person := Person&#123;<br>      ID:   <span class="hljs-number">1</span>,<br>      Name: <span class="hljs-string">&quot;snow&quot;</span>,<br>      Age:  <span class="hljs-number">22</span>,<br>   &#125;<br>   <span class="hljs-keyword">var</span> students []Student<br>   copier.Copy(&amp;students, &amp;person)<br>   fmt.Println(students)<br>&#125;<br><span class="hljs-comment">//[&#123;1 snow 22&#125;]</span><br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a href="https://github.com/jinzhu/copier">copier库</a></p><p><code>copier</code>还有很多玩法，本文章值列举了自己在改造时使用过的方法，具体信息可以看官方源码和文档</p>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go项目场景一</title>
    <link href="/2021/09/24/Go%E9%A1%B9%E7%9B%AE%E5%9C%BA%E6%99%AF%E4%B8%80/"/>
    <url>/2021/09/24/Go%E9%A1%B9%E7%9B%AE%E5%9C%BA%E6%99%AF%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>在项目启动后有一个会开一个<code>goroutine</code>，里面有一个<code>chan</code>接收消息数据，如果接收到消息就将数据库的某些配置拉到本地进行配置下发</p><p>之前是设置定时器，每隔一段时间就自动给<code>chan</code>发送消息，现在向进行<strong>实时配置下发</strong>，就是某些API被调用后(对指定数据库消息进行变更的API)将给<code>chan</code>发送消息</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>因为API调用时并发进行的，如果在短时间内有大量的特定API调用，则都会给<code>chan</code>发送消息，而对<code>chan</code>的处理只是单协程，那么之后的请求将会<strong>在<code>chan</code>外堵塞</strong>，可能就达到不了<strong>实时</strong>下发的效果</p><p>对于发送消息，其实<strong>只要后面调用API的<code>goroutine</code>发送的消息即可</strong>，因为后面更新数据库的信息里肯定是包含了前面更新的信息</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><blockquote><p>目前对<code>chan</code>的处理只是单协程，<strong>能不能使用多<code>goroutine</code>去并发竞争<code>chan</code>，提高对<code>chan</code>的处理能力？</strong></p></blockquote><p>不能，因为<code>chan</code>中要更改一个全局<code>map</code>的变量，会加锁，即使使用多<code>goroutine</code>在发送消息给<code>chan</code>后也会进行堵塞</p><p>​    </p><blockquote><p>能不能使用一种机制，就是给发送消息给chan时，看是否有消息在chan外堵塞，有的话则将自己进行替换</p></blockquote><p>因为之后更新的消息肯定是包含前面更新的消息，所以在之前调用API的<code>goroutine</code>和之后调用API的<code>goroutine</code>同时发送消息时，<strong>应该是该舍弃前面的消息保留后面的消息</strong></p><p>原理上是可行的，但实际上操作起来很难，<strong>因为无法获知chan中是否有缓存</strong>，只能取出，并且只能取一个，而且取值操作在<code>chan</code>没有缓存时还会堵塞</p><p>并且还是在每次API调用操作时都会给<code>chan</code>发消息，根本上还是会造成<code>chan</code>的堵塞</p><p>​    </p><blockquote><p>由上面，想是否可以有一种机制，使得不是每次调API用都给<code>chan</code>发送消息，而是满足一定条件才会给<code>chan</code>发送消息</p></blockquote><p>这样可以根本解决<code>chan</code>堵塞的问题，<strong>只要在每次发送前短暂的等待一会</strong>，<strong>看是否有新的<code>goroutine</code>要发送消息，如果要则抛弃本次的消息发送</strong></p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>定义实时配置下发的全局变量和结构体</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> realtimeMachine *RealTimeMachine<br><span class="hljs-keyword">type</span> RealTimeMachine <span class="hljs-keyword">struct</span> &#123;<br>   Random <span class="hljs-keyword">int64</span> <span class="hljs-comment">//生成随机数</span><br>   Num    <span class="hljs-keyword">int</span>   <span class="hljs-comment">//强制下发触发次数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>思路：<strong>每次发送前随机生成64位的int数赋值给实时配置下发器的变量，然后设置一个短暂的等待时间，时间后看该变量是否发生改变，如果发生改变则放弃给chan发送消息，如果没有改变则给chan发送消息</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ImmediatelyUpdateApi</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      xxxApi.ImmediatelyUpdateApi(loader, realtimeMachine, rand.Int63()) <span class="hljs-comment">//随机生成64位int数</span><br>   &#125;()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(xxxApi *xxxApixxx)</span> <span class="hljs-title">ImmediatelyUpdateApi</span><span class="hljs-params">(loader Loader, machine *translate.RealTimeMachine, random <span class="hljs-keyword">int64</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> err := xxxApi.Translate(loader); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">//去数据库更新配置到本地变量</span><br>logger.Warn(<span class="hljs-string">&quot;timed get api is null&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> !xxxApi.CompareDiff() &#123; <span class="hljs-comment">//如果更新后本地变量没有发生变化，则不需要发送消息给chan了</span><br><span class="hljs-keyword">return</span><br>&#125;<br>machine.Random = random<br>machine.Num++<br><span class="hljs-comment">//虽然可能因为多次并发而达不到每十次强制触发一次，但是只要有运行多次强制触发一次的机制即可</span><br><span class="hljs-keyword">if</span> machine.Num == <span class="hljs-number">10</span> &#123;<br>machine.Num = <span class="hljs-number">0</span><br>xxxApi.Chan &lt;- <span class="hljs-string">&quot;message&quot;</span><br><span class="hljs-keyword">return</span><br>&#125;<br>    <span class="hljs-comment">//设置等待更新时间，时间内如果没有发生更改(没有新的goroutine发送消息)则发送消息</span><br>time.Sleep(time.Millisecond * <span class="hljs-number">300</span>)<br><span class="hljs-keyword">if</span> machine.Random == random &#123;<br>xxxApi.Ch &lt;- <span class="hljs-string">&quot;message&quot;</span><br><span class="hljs-keyword">return</span><br>&#125;<br>    <span class="hljs-comment">//如果发生更改则放弃本次消息发送</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><p>上面有一个计数强制发送的机制，是因为避免这种情况发生：</p><p>加入设置的是等待时间300ms，如果每300ms内都有新goroutine发送，那么就会一直放弃本次消息发送，迟迟无法更新配置信息</p><p>那么就需要设置一个<strong>强制发送的机制</strong>，就是累计指定次数，就必须发送消息一次，这样就会闭上上诉情况</p><p><del><strong>虽然可能因为多次并发而达不到指定次数强制触发一次(如果要则需要上锁，那么就会影响性能)，但是只要有运行多次强制触发一次的机制即可</strong></del></p><p><strong>下面进行了优化更新！</strong></p><h1 id="优化解决"><a href="#优化解决" class="headerlink" title="优化解决"></a>优化解决</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> realtimeMachine *RealTimeMachine<br><span class="hljs-keyword">type</span> RealTimeMachine <span class="hljs-keyword">struct</span> &#123;<br>   Random <span class="hljs-keyword">int64</span> <span class="hljs-comment">//生成随机数</span><br>   Tiem   <span class="hljs-keyword">int64</span> <span class="hljs-comment">//记录最大超时时间</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>对野生goroutine进行兜底保护</strong></p><p>因为<code>gin</code>框架已经对每一个接口进行了兜底保护，即使发送panic也不会宕机(<code>panic</code>),但是如果在接口中使用了<strong>野生goroutine并且在里面发升了<code>panic</code>，那么整个程序都会崩溃！(包括主程序)</strong></p></li><li><p>使用最大超时时间代替强制发送次数机制，避免了<strong>因多次并发而达不到指定次数强制触发一次</strong>，使得发送时间更加平滑</p></li><li><p><strong>最小等待时间应该大于chan接收信息后函数处理的平均时间</strong></p><p>如果小于，则等待后的时间差还是可能最造成chan阻塞(比如处理10ms，等待2ms，那么如果每3ms发送一次信息，那么每次都会按时发送不会被丢弃并且也会阻塞在chan外(内部用了锁))</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ImmediatelyUpdateApi</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <br>       <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//兜底保护</span><br>           <span class="hljs-keyword">if</span> err:=<span class="hljs-built_in">recover</span>();err!=<span class="hljs-literal">nil</span>&#123;<br>               logger(<span class="hljs-string">&quot;happen panic!&quot;</span>)<br>           &#125;<br>       &#125;<br>       xxxApi.ImmediatelyUpdateApi(loader, realtimeMachine, rand.Int63()) <span class="hljs-comment">//随机生成64位int数</span><br>   &#125;()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(xxxApi *xxxApixxx)</span> <span class="hljs-title">ImmediatelyUpdateApi</span><span class="hljs-params">(loader Loader, machine *translate.RealTimeMachine, random <span class="hljs-keyword">int64</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> err := xxxApi.Translate(loader); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">//去数据库更新配置到本地变量</span><br>logger.Warn(<span class="hljs-string">&quot;timed get api is null&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> !xxxApi.CompareDiff() &#123; <span class="hljs-comment">//如果更新后本地变量没有发生变化，则不需要发送消息给chan了</span><br><span class="hljs-keyword">return</span><br>&#125;<br>machine.Random = random<br>now := time.Now().Unix()<br><span class="hljs-keyword">if</span> now-machine.Time &lt; <span class="hljs-number">1</span> &#123; <span class="hljs-comment">//设置最大超时时间，每隔1s的请求都会强制发送</span><br>machine.Time = now<br>envoyRemoteApi.Ch &lt;- <span class="hljs-string">&quot;envoy&quot;</span><br><span class="hljs-keyword">return</span><br>&#125;<br>    <span class="hljs-comment">//设置最小等待更新时间，时间内如果没有发生更改(没有新的goroutine发送消息)则发送消息</span><br>time.Sleep(time.Millisecond * <span class="hljs-number">300</span>) <span class="hljs-comment">//最小等待时间应该大于发送消息后函数的处理时间</span><br><span class="hljs-keyword">if</span> machine.Random == random &#123;<br>xxxApi.Ch &lt;- <span class="hljs-string">&quot;message&quot;</span><br><span class="hljs-keyword">return</span><br>&#125;<br>    <span class="hljs-comment">//如果发生更改则放弃本次消息发送</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go实现防重放攻击</title>
    <link href="/2021/09/10/Go%E5%AE%9E%E7%8E%B0%E9%98%B2%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/"/>
    <url>/2021/09/10/Go%E5%AE%9E%E7%8E%B0%E9%98%B2%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h1><p>API重放攻击（Replay Attacks）又称重播攻击、回放攻击。他的原理就是把<strong>之前窃听到的数据原封不动的重新发送给接收方</strong>。<strong>HTTPS并不能防止这种攻击</strong>，虽然传输的数据是经过加密的，窃听者无法得到数据的准确定义，但是可以从请求的接收方地址分析出这些数据的作用。</p><p>比如用户登录请求时攻击者虽然无法窃听密码，但是却可以截取加密后的口令然后将其重放，从而利用这种方式进行有效的攻击。</p><p>比如给自己账号充值1000元，如果能窃听到这个命令并进行不停重放发送给服务器，那么自己账户上的金额将不停增加</p><p>首先要明确一个事情，<strong>重放攻击是二次请求</strong>，黑客通过抓包获取到了请求的HTTP报文，然后黑客自己编写了一个类似的HTTP请求，发送给服务器。也就是说服务器处理了两个请求，<strong>先处理了正常的HTTP请求，然后又处理了黑客发送的篡改过的HTTP请求</strong></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><blockquote><p>根据时间戳的方案</p></blockquote><p>每次HTTP请求，都需要<strong>加上timestamp参数</strong>，然后把timestamp和其他参数加密到token里。因为一次正常的HTTP请求，从发出到达服务器一般都不会超过60s，所以服务器收到HTTP请求之后，首先判断时间戳参数与当前时间相比较，<strong>是否超过了60s，如果超过了则认为是非法的请求</strong></p><p>​    </p><p>一般情况下，<strong>黑客从抓包重放请求耗时远远超过了60s</strong>，所以此时请求中的stime参数已经失效了。 </p><p>​    </p><p>但这种方式的漏洞也是显而易见的，如果在60s之内进行重放攻击，那就没办法了，所以这种方式不能保证请求仅一次有效</p><p>​    </p><blockquote><p>基于应答式的方案</p></blockquote><p>每次请求前，会先去服务器会根据时间戳获取一个随机数，服务器就会将随机数放在缓存中，在请求时参数带上随机数，将随机数加密在token里，服务器就会校验缓存中是否有随机数，有的话就通过并且删除随机数，没有则认为是非法请求。</p><p>并且服务器缓存的<strong>随机数设置一个60秒的存活时间</strong>，防止客户端拿到随机数后不进行后续操作导致随机数在缓存无法被清除而累积的问题    </p><h1 id="Go实现防重放攻击"><a href="#Go实现防重放攻击" class="headerlink" title="Go实现防重放攻击"></a>Go实现防重放攻击</h1><p>使用<strong>基于应答式的方案</strong>实现防重放攻击</p><p><strong>获取随机数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PutRandom</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>   value, err := setRandom()<br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      c.JSON(<span class="hljs-number">400</span>,fmt.Sprintf(<span class="hljs-string">&quot;redis set random err:%v&quot;</span>, err))<br>      <span class="hljs-keyword">return</span><br>   &#125;<br>   c.JSON(<span class="hljs-number">200</span>, value)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setRandom</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, error)</span></span> &#123;<br>rand.Seed(time.Now().UnixNano()) <span class="hljs-comment">// 设置纳秒级别的随机数</span><br>random := rand.Intn(math.MaxInt32)<br>str := strconv.Itoa(random)<br><span class="hljs-keyword">if</span> _, err := Redis.Set(str, <span class="hljs-string">&quot;true&quot;</span>, time.Second*<span class="hljs-number">60</span>).Result(); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 设置随机数存活时间为60s</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> str, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><p><strong>校验随机数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CheckRandom</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>   v := c.GetHeader(<span class="hljs-string">&quot;random&quot;</span>) <span class="hljs-comment">// 也可以存在token里</span><br>   <span class="hljs-keyword">if</span> err := checkRandom(v); err != <span class="hljs-literal">nil</span> &#123;<br>      c.JSON(<span class="hljs-number">400</span>, <span class="hljs-string">&quot;random verify fail&quot;</span>) <span class="hljs-comment">// 检验失败</span><br>      <span class="hljs-keyword">return</span><br>   &#125;<br>   c.JSON(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;random verify success&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkRandom</span><span class="hljs-params">(val <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">if</span> _, err := Redis.Get(val).Result(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err <span class="hljs-comment">// 没有查到随机数则返回失败</span><br>&#125;<br>client.Del(val) <span class="hljs-comment">// 检验成功后删除随机数，防止重放攻击</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go安装和使用Redis</title>
    <link href="/2021/09/03/Go_Redis/"/>
    <url>/2021/09/03/Go_Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-安装-Redis"><a href="#Docker-安装-Redis" class="headerlink" title="Docker 安装 Redis"></a>Docker 安装 Redis</h1><blockquote><p>创建data文件做数据持久化存储时</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs sh">mkdir /data/redis<br>mkdir /data/redis/data <br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>做redis容器启动后的配置文件</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">touch /data/redis/redis.conf<br></code></pre></td></tr></table></figure><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># Redis默认不是以守护进程的方式运行</span><br>daemonize no<br><br><span class="hljs-meta"># 指定Redis监听端口，默认端口为6379</span><br>port <span class="hljs-number">6379</span><br><br><span class="hljs-meta"># 绑定的主机地址，不要绑定容器的本地127.0.0.1地址，因为这样就无法在容器外部访问</span><br>bind <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br><br><span class="hljs-meta"># 持久化</span><br>appendonly yes<br><br><span class="hljs-meta">#设置密码</span><br>requirepass password  <br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>启动命令</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -p 6379:6379 --name redis -v /docker/redis/redis.conf:/etc/redis/redis.conf -v /docker/redis/data:/data -d redis redis-server /etc/redis/redis.conf<br></code></pre></td></tr></table></figure><p><strong>命令解释</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run redis # 从redis镜像运行容器<br>-p 6379:6379 # 映射本地6379端口到容器6379端口，前为本地端口<br>--name redis # 设置容器名称为redis，方便以后使用docker ps进行管理<br>-v /data/redis/redis.conf:/etc/redis/redis.conf # 关联本地/data/redis/redis.conf文件到容器中/etc/redis/redis.conf，同样，前为本地<br>-v /data/redis/data:/data # 关联本地/docker/redis/data到容器内/data目录，此为存放redis数据的目录，为方便以后升级redis，而数据可以留存<br>-d # 后台启动，使用此方式启动，则redis.conf中daemonize必须设置为no，否则会无法启动<br>redis-server /etc/redis/redis.conf # 在容器内启动redis-server的命令，主要是为了加载配置<br></code></pre></td></tr></table></figure><h1 id="Go-中使用-Redis"><a href="#Go-中使用-Redis" class="headerlink" title="Go 中使用 Redis"></a>Go 中使用 Redis</h1><blockquote><p>安装 go-redis v8</p></blockquote><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> github.<span class="hljs-keyword">com</span>/<span class="hljs-keyword">go</span>-redis/redis/v8  <br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>初始化 redis client</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> rdb *redis.Client<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitRedisClii</span><span class="hljs-params">(cfg config.RedisConf)</span> <span class="hljs-title">error</span></span> &#123;<br>   rdb = redis.NewClient(&amp;redis.Options&#123;<br>      Addr:     cfg.Address, <br>      Password: cfg.Password, <span class="hljs-comment">//设置好的密码</span><br>      DB:       <span class="hljs-number">0</span>, <span class="hljs-comment">//要连接的redis库</span><br>      PoolSize: <span class="hljs-number">100</span>, <span class="hljs-comment">//连接池的最大连接数</span><br>   &#125;)<br><br>   ctx, cancel := context.WithTimeout(context.Background(), <span class="hljs-number">5</span>*time.Second)<br>   <span class="hljs-keyword">defer</span> cancel()<br>   _, err := rdb.Ping(ctx).Result() <span class="hljs-comment">//检测心跳，确认是否能连接上</span><br>   <span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetRedisCli</span><span class="hljs-params">()</span> *<span class="hljs-title">redis</span>.<span class="hljs-title">Client</span></span> &#123; <br>   <span class="hljs-keyword">return</span> rdb<br>&#125;  <br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>使用 redis</p></blockquote><p>本次以查询评论功能为例</p><p>使用的rpc的调用方式，属于所写的星辰缘项目，是一个微服务架构的项目，在后续中也会逐步完善相关笔记</p><ul><li><p>在使用redis之前要思考为什么使用redis，在什么地方使用redis</p></li><li><p>此次是在查询文章评论功能上使用redis文章评论使用，将db查询结果进行json序列化作为value存入redis（不严谨，目前初始学，暂时先这样），并且设置时间为5s</p></li><li><p>这样每次查就会先去redis中查找是否有相关信息，没有的话再去mysql中找，并且将结果再存入到redis中且设置存活时间为5s</p></li><li><p>这样用户每次新写了评论后可能会5s中后才能看到自己写的评论（不严谨，现在暂时逻辑先这样），虽然<u><strong>造成了延迟，牺牲了及时性</strong></u>，但是却有效<u><strong>保护了mysql</strong></u></p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *CommentServer)</span> <span class="hljs-title">QueryComment</span><span class="hljs-params">(ctx context.Context, req *comment.QueryCommentREQ, rsp *comment.QueryCommentRSP)</span> <span class="hljs-title">error</span></span> &#123;<br>   <span class="hljs-keyword">var</span> comments []model.Comment<br>   <span class="hljs-keyword">var</span> ack []*comment.CommentContent<br>   info, err := redisCli.GetRedisCli().Get(ctx, <span class="hljs-string">&quot;comment_id_&quot;</span>+strconv.Itoa(<span class="hljs-keyword">int</span>(req.CommentId))).Bytes() <span class="hljs-comment">//先redis中找数据</span><br>   <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">//找到了redis中的数据</span><br>      fmt.Println(<span class="hljs-string">&quot;use redis!&quot;</span>)<br>      err = json.Unmarshal(info, &amp;ack) <span class="hljs-comment">//反序列化</span><br>      rsp.Code = <span class="hljs-keyword">uint32</span>(common.StatusRPCOK)<br>      rsp.Comment = ack<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>   &#125;<br>   err = db.QueryComment(req.CommentId, req.Type, &amp;comments) <span class="hljs-comment">//没有找到就去mysql中查询</span><br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      rsp.Code = <span class="hljs-keyword">uint32</span>(common.ErrRPCCode)<br>      rsp.Err = err.Error()<br>      <span class="hljs-keyword">return</span> errors.Wrap(err, <span class="hljs-string">&quot;db query comment err&quot;</span>)<br>   &#125;<br>   <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> comments &#123;<br>      <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span>微服务调微服务优化</span><br>      rspUser, err := client.GetIDUser(v.UserID) <span class="hljs-comment">//去account 微服务中查询user_id的具体信息</span><br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         rsp.Code = <span class="hljs-keyword">uint32</span>(common.ErrRPCCode)<br>         rsp.Err = err.Error()<br>         <span class="hljs-keyword">return</span> errors.Wrap(err, <span class="hljs-string">&quot;db get id user err&quot;</span>)<br>      &#125;<br>      ack = <span class="hljs-built_in">append</span>(ack, &amp;comment.CommentContent&#123;<br>         Id:         v.ID,<br>         CommentId:  v.CommentedID,<br>         Type:       <span class="hljs-keyword">uint32</span>(v.Type),<br>         Content:    v.Content,<br>         Time:       v.Time,<br>         UserId:     v.UserID,<br>         UserAvatar: oss.DownloadUrl(rspUser.Avatar),<br>         UserName:   rspUser.Name,<br>         Love:       <span class="hljs-keyword">int64</span>(v.Love),<br>      &#125;)<br>   &#125;<br>   fmt.Println(<span class="hljs-string">&quot;user mysql!&quot;</span>)<br>   rsp.Code = <span class="hljs-keyword">uint32</span>(common.StatusRPCOK)<br>   rsp.Comment = ack<br>   data, _ := json.Marshal(ack) <span class="hljs-comment">//将查询结果序列化</span><br>    <span class="hljs-comment">//将查询结果存入redis，并设置存活时间为5s</span><br>   err = redisCli.GetRedisCli().Set(ctx, <span class="hljs-string">&quot;comment_id_&quot;</span>+strconv.Itoa(<span class="hljs-keyword">int</span>(req.CommentId)), <span class="hljs-keyword">string</span>(data), time.Second*<span class="hljs-number">5</span>).Err()<br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      rsp.Err = <span class="hljs-string">&quot;redis add comment err&quot;</span><br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="贴士"><a href="#贴士" class="headerlink" title="贴士"></a>贴士</h1><p><strong>go-redis中如果Get一个不存在的键会直接返回err</strong>，而不是空字符串</p>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>星辰缘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Goroutine使用准则</title>
    <link href="/2021/09/03/Goroutine%E4%BD%BF%E7%94%A8%E5%87%86%E5%88%99/"/>
    <url>/2021/09/03/Goroutine%E4%BD%BF%E7%94%A8%E5%87%86%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Gouroutine</code>是Go开发中最常用的功能之一，开启一个Goroutine很简单，但是想要控制一个<code>Goroutine</code>的生命周期却需要一些技巧</p><p>最常见的是<strong>goroutine泄露</strong>问题</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">leak</span><span class="hljs-params">()</span></span>&#123;<br>    ch:=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>        val:=&lt;-ch<br>        fmt.PrintIn(<span class="hljs-string">&quot;received a value:&quot;</span>,val)<br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>函数退出后<code>goroutine</code>并不会退出，而且也不会接收到数据，处于一直被堵塞的状态，并且会占用资源，这就是常见的<code>goroutine</code>泄露(你以为它结束了，其实它没有)</p><h1 id="准则"><a href="#准则" class="headerlink" title="准则"></a>准则</h1><blockquote><p>goroutine最常用的准则</p></blockquote><p><strong>不要开启一个goroutine如果你不知道它什么时候结束</strong></p><p>任何时候开启一个<code>goroutine</code>都要问自己两个问题</p><ul><li>它什么时候结束</li><li>如何让它结束</li></ul><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><blockquote><p>设置超时控制</p></blockquote><p>对于一些<code>goroutine</code>应该还要<strong>设置超时控制</strong>，使用<code>context</code></p><p>给<code>goroutine</code>一个超时时间，这样<code>goroutine</code>的结束就在掌握之中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goroutine_1</span><span class="hljs-params">()</span></span> &#123;<br>   ctx, cancel := context.WithTimeout(context.TODO(), <span class="hljs-number">10</span>*time.Second)<br>   <span class="hljs-keyword">defer</span> cancel()<br><br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context)</span></span> &#123; <br>      xxx()<br>   &#125;(ctx)<br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>设置recover兜底保护</p></blockquote><p>对于一个我们不知道什么时候会启用的<code>goroutine</code>称为<strong>野生goroutine</strong>（如调用指定接口其业务逻辑会启动一个<code>goroutine</code>）</p><p>在<code>Gin</code>框架中，在我的业务逻辑接口中，即使发生了<code>Panic</code>行为(如数组越界，使用未初始化的map等)也不会使整个程序崩溃，因为在<strong>Gin为每一个调用者都自动启动revover( )进行兜底保护</strong></p><p>但是如果在业务逻辑的接口中又使用了<code>goroutine</code>，并且<strong>在goroutine中发生了Panic行为，那么就会导致整个程序的崩溃</strong></p><p><strong>所以我们对于野生的goroutine要使用recover( )进行兜底保护</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goroutine_2</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <br>      <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>         <span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>            logger.Errorf(<span class="hljs-string">&quot;happen panic!&quot;</span>)<br>         &#125;<br>      &#125;()<br>       xxx()<br>   &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>使用chan来监听和控制goroutine的生命周期</p></blockquote><p><strong>比如在main函数中同时监听两个端口的正确姿势</strong></p><ul><li>同时监听，平滑退出</li><li>能在main中管理<code>goroutine</code>的生命周期并知道它何时退出</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> error, <span class="hljs-number">2</span>)<br>   stop := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      done &lt;- rpc.GatewayRPC(stop)<br>   &#125;()<br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      done &lt;- api.ServiceAPI(stop)<br>   &#125;()<br>    <br>   <span class="hljs-keyword">var</span> stopped <span class="hljs-keyword">bool</span><br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">cap</span>(done); i++ &#123;<br>      <span class="hljs-keyword">if</span> err := &lt;-done; err != <span class="hljs-literal">nil</span> &#123;<br>         fmt.Println(<span class="hljs-string">&quot;err: &quot;</span>, err)<br>      &#125;<br>      <span class="hljs-keyword">if</span> !stopped &#123;<br>         stopped = <span class="hljs-literal">true</span><br>         <span class="hljs-built_in">close</span>(stop)<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用空结构体传递信号(<strong>空结构体不占用内存，用来作为通道的信号传递最好</strong>)</p><p>一旦某个<code>goroutine</code>出现错误就会发送错误信息给done</p><p>done接收到信息后结汇关闭stop，每个有stop通道的<code>goroutine</code>收到信号后就会优雅关闭服务(<code>Shutdown</code>函数)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ServiceAPI</span><span class="hljs-params">(stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;<br>   r := router.AgentRouter()<br>   server := &amp;http.Server&#123;<br>      Addr:         <span class="hljs-string">&quot;:8080&quot;</span>,<br>      Handler:      r,<br>   &#125;<br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      &lt;-stop<br>      server.Shutdown(context.TODO())<br>   &#125;()<br>   <span class="hljs-keyword">return</span> server.ListenAndServe()<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ginkgo&amp;Gomega</title>
    <link href="/2021/08/09/Ginkgo&amp;Gomega/"/>
    <url>/2021/08/09/Ginkgo&amp;Gomega/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近公司项目实现标准化，打算给项目加上单元测试和集成测试，在Go的项目中由调研后打算采用<code>Ginkgo</code>和<code>Gomega</code>，看了下官方文档和github上的测试后写下点心得</p><p><code>Ginkgo</code>是Go语言的一个行为驱动开发(BDD)风格的<strong>测试框架</strong>，通常和Gomega一起使用</p><p><code>Gomega</code>是一个<strong>匹配/断言库</strong>，通常与Ginkgo测试框架搭配使用</p><p><a href="https://ke-chain.github.io/ginkgodoc/">Ginkgo官方中文文档</a></p><p><a href="https://onsi.github.io/gomega/">Gomega官方文档</a></p><p><a href="https://blog.gmem.cc/ginkgo-study-note">Ginkgo使用笔记</a></p><p>下面的文章对上面的文档进行了参考和引用</p><p>对于测试的方法和使用请参考具体的文档，本文章主要介绍实战的使用</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装Ginkgo</p><figure class="highlight vim"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> -<span class="hljs-keyword">u</span> github.<span class="hljs-keyword">com</span>/onsi/ginkgo/ginkgo<br></code></pre></td></tr></table></figure><p>安装Gomega</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> github.<span class="hljs-keyword">com</span>/onsi/gomega/...<br></code></pre></td></tr></table></figure><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p><code>Ginkgo</code>与Go自带测试挂钩，允许使用<code>go test</code>运行<code>Ginkgo</code>套件</p><blockquote><p>创建套件</p></blockquote><p>如果要为一个包编写<code>Ginkgo</code>测试，首先需要使用命令创建套件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> pkg/book <span class="hljs-comment">#假设要为book包编写测试</span><br>ginkgo bootstrap<br></code></pre></td></tr></table></figure><p>上诉命令会生成文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> books_test<br> <br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-comment">// 使用点号导入，把这两个包导入到当前命名空间</span><br>    . <span class="hljs-string">&quot;github.com/onsi/ginkgo&quot;</span><br>    . <span class="hljs-string">&quot;github.com/onsi/gomega&quot;</span><br>    <span class="hljs-string">&quot;testing&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestBooks</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-comment">// 将Ginkgo的Fail函数传递给Gomega，Fail函数用于标记测试失败，这是Ginkgo和Gomega唯一的交互点</span><br>    <span class="hljs-comment">// 如果Gomega断言失败，就会调用Fail进行处理</span><br>    RegisterFailHandler(Fail)<br> <br>    <span class="hljs-comment">// 启动测试套件</span><br>    RunSpecs(t, <span class="hljs-string">&quot;Books Suite&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>创建完成后就可以在当前包下使用<code>ginkgo</code>或者<code>go test</code>执行测试套件</p><p>​    </p><blockquote><p>添加Spec</p></blockquote><p>上面的空测试套件没有什么价值，我们需要在此套接下编写测试（Spec）。虽然可以在<code>books_suite_test.go</code>中编写测试，但是推荐分离到独立的文件中，特别是包中有多个需要被测试的源文件的情况下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ginkgo generate book #执行该命令可以生成源文件为book.go的测试<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> _ = Describe(<span class="hljs-string">&quot;Book&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><br>&#125;)<br></code></pre></td></tr></table></figure><ul><li><code>Describe</code>块用来组织<code>Specs</code>，其中可以包含任意数量的</li><li><code>It</code>：可以在<code>Describe</code>、<code>Context</code>这两种容器块内编写<code>Spec</code>，每个<code>Spec</code>写在<code>It</code>块中；为了贴合自然语言，可以使用<code>It</code>的别名<code>Specify</code></li><li>使用<code>Describe</code>和<code>Context</code>来标识组织代码的具体行为</li><li><code>BeforeEach</code>：在<code>Spec</code>（It块）运行之前执行，嵌套<code>Describe</code>时最外层<code>BeforeEach</code>先执行</li><li><code>AfterEach</code>：在<code>Spec</code>运行之后执行，嵌套<code>Describe</code>时最内层<code>AfterEach</code>先执行</li><li><code>JustBeforeEach</code>：在<code>It</code>块，所有<code>BeforeEach</code>之后执行，在<code>It</code>之前运行</li></ul><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>现在要对网页后端的多个API接口进行集成测试</p><blockquote><p>初步</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> _ = Describe(<span class="hljs-string">&quot;Endpoint&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> (<br>reqJSON <span class="hljs-keyword">string</span><br>res     *http.Response<br>req     *http.Request<br>client  *http.Client<br>url     <span class="hljs-keyword">string</span><br>method  <span class="hljs-keyword">string</span><br>err     error<br>)<br><br>BeforeEach(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>client = &amp;http.Client&#123;&#125;<br>res = &amp;http.Response&#123;&#125;<br>req = &amp;http.Request&#123;&#125;<br>&#125;)<br><br>Context(<span class="hljs-string">&quot;test test1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>BeforeEach(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>url = <span class="hljs-string">&quot;http://127.0.0.1:8080/test1&quot;</span><br>method = <span class="hljs-string">&quot;GET&quot;</span><br>req, err = http.NewRequest(method, url, strings.NewReader(reqJSON))<br>gomega.Expect(err).ShouldNot(gomega.HaveOccurred())<br><br>req.Header.Add(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>)<br>req.Header.Add(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>)<br><br>res, err = client.Do(req)<br>gomega.Expect(err).ShouldNot(gomega.HaveOccurred())<br>&#125;)<br><span class="hljs-comment">//直接对比res的status_code，简便</span><br>It(<span class="hljs-string">&quot;test1 success&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>gomega.Expect(res.StatusCode).Should(gomega.Equal(http.StatusOK))<br>&#125;)<br><br>&#125;)<br><br>Context(<span class="hljs-string">&quot;test test2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>BeforeEach(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>url = <span class="hljs-string">&quot;http://127.0.0.1:8080/test2/1&quot;</span><br>method = <span class="hljs-string">&quot;GET&quot;</span><br>req, err = http.NewRequest(method, url, strings.NewReader(reqJSON))<br>gomega.Expect(err).ShouldNot(gomega.HaveOccurred())<br><br>req.Header.Add(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>)<br><br>res, err = client.Do(req)<br>gomega.Expect(err).ShouldNot(gomega.HaveOccurred())<br>&#125;)<br><span class="hljs-comment">//实现接口后可以自定义匹配规则，匹配方式灵活，并且可以打印自定义错误消息</span><br>It(<span class="hljs-string">&quot;test2 success&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>gomega.Expect(res).To(test.RepresentJSONObject(http.StatusOK))<br>&#125;)<br><br>&#125;)<br><br>Context(<span class="hljs-string">&quot;test test3&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>BeforeEach(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>url = <span class="hljs-string">&quot;http://127.0.0.1:8080/test3/1&quot;</span><br>method = <span class="hljs-string">&quot;PUT&quot;</span><br>reqJSON = <span class="hljs-string">&quot;&#123;\&quot;id\&quot;:1&#125;&quot;</span><br>req, err = http.NewRequest(method, url, strings.NewReader(reqJSON))<br>gomega.Expect(err).ShouldNot(gomega.HaveOccurred())<br><br>req.Header.Add(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>)<br>req.Header.Add(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br><br>res, err = client.Do(req)<br>gomega.Expect(err).ShouldNot(gomega.HaveOccurred())<br>&#125;)<br><span class="hljs-comment">//通过自定义匹配规则返回的err判定</span><br>It(<span class="hljs-string">&quot;test3 success&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>_, err := test.RepresentJSONObject(http.StatusOK).Match(res)<br>gomega.Expect(err).ShouldNot(gomega.HaveOccurred())<br>&#125;)<br><span class="hljs-comment">//通过自定义匹配规则返回的true判定，只答应ture和false的消息</span><br>It(<span class="hljs-string">&quot;test3 no err&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>gomega.Expect(test.RepresentJSONObject(http.StatusOK).Match(res)).Should(gomega.Equal(<span class="hljs-literal">true</span>))<br>&#125;)<br>&#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>上诉的思想就是<strong>每个测试组件都提前定义好<code>request</code>和<code>response</code>，通过发送给<code>client</code>的<code>request</code>加上<code>Gomega</code>断言收到的response来进行测试</strong></li><li>把每个测试组件都要使用的变脸，如<code>url、method、client</code>等放最初的全局变量</li><li>每次使用前都要重新初始化<code>client</code>、<code>request</code>、<code>response</code>则放入<code>BeforeEach</code>（如果使用了<code>response.Body</code>）可以使用<code>AfterEach</code>进行关闭</li></ul><p>​    </p><p><strong>对上面不同的Gomega断言类型进行说明</strong></p><ul><li><p><code>gomega.Expect(res.StatusCode).Should(gomega.Equal(http.StatusOK))</code></p><p><code>Should</code>和<code>To</code>相同，表示肯定，<code>gomega.Equal</code>则是表示断言相等，连起来就是我们实际得到的<code>res.StatusCode</code>应该和<code>http.StatusOK</code>相同，相同测试成功，不同测试失败</p></li><li><p><code>gomega.Expect(err).ShouldNot(gomega.HaveOccurred())</code></p><p><code>ShouldNot</code>和<code>NotTo</code>相同，表示否定，<code>gomega.HaveOccurred()</code>指示<code>non-nill</code>的<code>error</code>则成功，连起来就是如果出现<code>non-nil</code>的<code>error</code>就测试失败，<code>error</code>为<code>nil</code>则测试成功，则是<strong>非常典型的Go错误测试模式</strong></p></li><li><p><code>gomega.Expect(res).To(test.RepresentJSONObject(http.StatusOK))</code></p><p>自定义匹配规则，只要<strong>实现<code>Match</code>、<code>FailureMessage</code>、<code>NegatedFailureMessage</code>方法的接口</strong>就行，好处就是<strong>匹配规则灵活多变</strong>(传入的http.StatusOK作为expected去Match Expect中的 res)，匹配结果返回的是<code>false</code>和<code>non-err</code>则为测试失败</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RepresentJSONObject</span><span class="hljs-params">(expected <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">types</span>.<span class="hljs-title">GomegaMatcher</span></span> &#123;<br>   <span class="hljs-keyword">return</span> &amp;representJSONMatcher&#123;<br>      expected: expected,<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> representJSONMatcher <span class="hljs-keyword">struct</span> &#123;<br>   expected <span class="hljs-keyword">interface</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(matcher *representJSONMatcher)</span> <span class="hljs-title">Match</span><span class="hljs-params">(actual <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(success <span class="hljs-keyword">bool</span>, err error)</span></span> &#123;<br>   response, ok := actual.(*http.Response)<br>   <span class="hljs-keyword">if</span> !ok &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, fmt.Errorf(<span class="hljs-string">&quot;RepresentJSONObject matcher expects an http.Response&quot;</span>)<br>   &#125;<br><br>   <span class="hljs-keyword">if</span> !reflect.DeepEqual(matcher.expected.(<span class="hljs-keyword">int</span>), response.StatusCode) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, fmt.Errorf(<span class="hljs-string">&quot;actual and expect no equal ,expect is %d,actual is %d&quot;</span>, matcher.expected.(<span class="hljs-keyword">int</span>), response.StatusCode)<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(matcher *representJSONMatcher)</span> <span class="hljs-title">FailureMessage</span><span class="hljs-params">(actual <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(message <span class="hljs-keyword">string</span>)</span></span> &#123;<br>   <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Expected\n\t%#v\nto contain the JSON representation of\n\t%#v&quot;</span>, actual, matcher.expected)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(matcher *representJSONMatcher)</span> <span class="hljs-title">NegatedFailureMessage</span><span class="hljs-params">(actual <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(message <span class="hljs-keyword">string</span>)</span></span> &#123;<br>   <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Expected\n\t%#v\nnot to contain the JSON representation of\n\t%#v&quot;</span>, actual, matcher.expected)<br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>改进</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> _ = Describe(<span class="hljs-string">&quot;Endpoint&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><br>   JustAfterEach(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      warpper.InitTCli()<br>   &#125;)<br><br>   Context(<span class="hljs-string">&quot;test test1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      BeforeEach(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>         err := warpper.TCli.Do(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;/test1&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>         gomega.Expect(err).ShouldNot(gomega.HaveOccurred())<br>      &#125;)<br><br>      It(<span class="hljs-string">&quot;test1 success&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>         gomega.Expect(warpper.TCli.Res).To(warpper.RepresentJSONObject(http.StatusOK))<br>      &#125;)<br><br>   &#125;)<br><br>   Context(<span class="hljs-string">&quot;test test2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      BeforeEach(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>         err := warpper.TCli.Do(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;/test/1&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>         gomega.Expect(err).ShouldNot(gomega.HaveOccurred())<br>      &#125;)<br><br>      It(<span class="hljs-string">&quot;test2 success&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>         gomega.Expect(warpper.TCli.Res).To(warpper.RepresentJSONObject(http.StatusOK))<br>      &#125;)<br><br>   &#125;)<br><br>   Context(<span class="hljs-string">&quot;update endpoint&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      BeforeEach(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>         reqJSON := <span class="hljs-string">&quot;&#123;\&quot;id\&quot;:1&#125;&quot;</span><br>         err := warpper.TCli.Do(<span class="hljs-string">&quot;PUT&quot;</span>, <span class="hljs-string">&quot;/test3/1&quot;</span>, reqJSON)<br>         gomega.Expect(err).ShouldNot(gomega.HaveOccurred())<br>      &#125;)<br>      It(<span class="hljs-string">&quot;update endpoint success&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>         gomega.Expect(warpper.TCli.Res).To(warpper.RepresentJSONObject(http.StatusOK))<br>      &#125;)<br>   &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TeClient <span class="hljs-keyword">struct</span> &#123;<br>   Res    *http.Response<br>   Req    *http.Request<br>   Client *http.Client<br>   Err    error<br>&#125;<br><br><span class="hljs-keyword">var</span> TCli *TeClient<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitTCli</span><span class="hljs-params">()</span></span> &#123;<br>   TCli = &amp;TeClient&#123;<br>      Res:    &amp;http.Response&#123;&#125;,<br>      Req:    &amp;http.Request&#123;&#125;,<br>      Client: &amp;http.Client&#123;&#125;,<br>      Err:    <span class="hljs-literal">nil</span>,<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>采用自定义封装匹配规则和<code>gomega.HaveOccurred()</code>错误断言</p></li><li><p>对变量定义和初始化进行封装，因为每次在调用后都要重新初始化<code>TCli</code>，所以采用创建套件时初始化<code>TCli</code>和每次<code>It</code>结束后初始化的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//在ginkgo bootstrap创建套件的文件中，表示启动测试套件的每一个总Describe运行前都要执行的代码</span><br><span class="hljs-keyword">var</span> _ = BeforeSuite(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>   warpper.InitTCli()<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>对<code>BeforeEach</code>中<code>client</code>发送<code>request</code>和接收<code>response</code>的代码进行封装</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TeClient)</span> <span class="hljs-title">Do</span><span class="hljs-params">(method, url, reqJson <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<br>   adr := <span class="hljs-string">&quot;http://&quot;</span> + ip + url<br>   t.Req, t.Err = http.NewRequest(method, adr, strings.NewReader(reqJson))<br>   t.Req.Header.Add(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>)<br>   t.Req.Header.Add(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>)<br>   <span class="hljs-keyword">if</span> reqJson != <span class="hljs-string">&quot;&quot;</span> &#123;<br>      t.Req.Header.Add(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>   &#125;<br><br>   t.Res, t.Err = t.Client.Do(t.Req)<br>   <span class="hljs-keyword">if</span> t.Err != <span class="hljs-literal">nil</span> &#123;<br>      err := t.Err<br>      <span class="hljs-keyword">return</span> err<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>把测试组件相同的代码抽出成函数调用的方式，这样测试组件中的代码简介明了</p></li><li><p><code>Header.Add(“xxx”,&quot;xxx&quot;)</code>一般都是<code>token</code>、安全验证，因为在测试中使用的身份是一样的</p></li><li><p>对于有传如<code>request.Body</code>的<code>POST</code>方法才加<code>Header.Add(&quot;Content-Type&quot;, &quot;application/json&quot;)</code>，<code>GET</code>中不需要传入<code>request.Body</code>就不需要了</p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go切片在函数中的传递</title>
    <link href="/2021/07/29/Go%E5%88%87%E7%89%87%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E4%BC%A0%E9%80%92/"/>
    <url>/2021/07/29/Go%E5%88%87%E7%89%87%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E4%BC%A0%E9%80%92/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在优化之前实习生的代码，在做<code>control</code>层和<code>db</code>层之间参数传递的时候，老师提出了切片就是引用类型，那么在使用数据库<code>Find</code>功能时只需要传<code>model</code>切片即可，就不需要传切片指针了，但是自己在实验的时候发现直接传切片时无法获取值的，只有传切片指针才行</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//传切片</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetArticles</span><span class="hljs-params">(articles []model.Article)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">return</span> db.GetMysqlDB().Order(<span class="hljs-string">&quot;id desc&quot;</span>).Find(&amp;articles).Error<br>&#125;<br><span class="hljs-comment">//传切片指针</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetArticles</span><span class="hljs-params">(articles *[]model.Article)</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">return</span> db.GetMysqlDB().Order(<span class="hljs-string">&quot;id desc&quot;</span>).Find(&amp;articles).Error<br>&#125;<br></code></pre></td></tr></table></figure><p>后对此情况对网上的参考资料引用了大部分，做了少许修改的标注</p><p><a href="https://blog.csdn.net/LYue123/article/details/88363685?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.base">引用参考相关文章</a></p><h1 id="slice的参数"><a href="#slice的参数" class="headerlink" title="slice的参数"></a>slice的参数</h1><p>切片和数组是不一样的，数组是值类型，切片时引用类型，则我们相信在函数中传递地址切片，函数中改变，会直接影响到函数外与之对应的切片，现在做一个实验验证下想法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   s := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>   SliceTest1(s)<br>   fmt.Println(s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SliceTest1</span><span class="hljs-params">(num []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>   <span class="hljs-keyword">if</span> num != <span class="hljs-literal">nil</span> &amp;&amp; <span class="hljs-built_in">len</span>(num) &gt;= <span class="hljs-number">1</span> &#123;<br>      num[<span class="hljs-number">0</span>]=<span class="hljs-number">666</span><br>      <span class="hljs-keyword">return</span><br>   &#125;<br>   <span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">//[666 2 3]</span><br></code></pre></td></tr></table></figure><p>​    </p><p>上面的代码结果验证了我们的想法，但是在函数中打印切片的地址，则会发现<strong>和函数外对应的切片地址不一样</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   num := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>   fmt.Printf(<span class="hljs-string">&quot;main addr is %p\n&quot;</span>,&amp;num)<br>   SliceTest1(num)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SliceTest1</span><span class="hljs-params">(num []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>   fmt.Printf(<span class="hljs-string">&quot;function slice addr is %p\n&quot;</span>,&amp;num)<br>   <span class="hljs-keyword">if</span> num != <span class="hljs-literal">nil</span> &amp;&amp; <span class="hljs-built_in">len</span>(num) &gt;= <span class="hljs-number">1</span> &#123;<br>      num[<span class="hljs-number">0</span>]=<span class="hljs-number">666</span><br>      <span class="hljs-keyword">return</span><br>   &#125;<br>   <span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">//main addr is 0xc0000044a0</span><br><span class="hljs-comment">//function slice addr is 0xc0000044e0</span><br></code></pre></td></tr></table></figure><p>此时我们需要先了解下slice的实现</p><h1 id="Slice的实现"><a href="#Slice的实现" class="headerlink" title="Slice的实现"></a>Slice的实现</h1><p>切片不等同于数组，但他依赖数组实现的，切片是一种复合结构，它由三部分组成的，第一部分是底层数组的指针<code>ptr</code>，第二部分是切片大小<code>len</code>，最后是切片容量<code>cap</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SliceTest2</span><span class="hljs-params">()</span></span> &#123;<br>   num := [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>   slice := num[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]<br>   slice2 := num[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>]<br>   fmt.Printf(<span class="hljs-string">&quot;slice: %v,slice addr %p\n&quot;</span>, slice, &amp;slice)<br>   fmt.Printf(<span class="hljs-string">&quot;slice: %v,slice addr %p\n&quot;</span>, slice2, &amp;slice2)<br>   num[<span class="hljs-number">2</span>] = <span class="hljs-number">11</span><br>   fmt.Printf(<span class="hljs-string">&quot;slice: %v,slice addr %p\n&quot;</span>, slice, &amp;slice)<br>   fmt.Printf(<span class="hljs-string">&quot;slice: %v,slice addr %p&quot;</span>, slice2, &amp;slice2)<br>&#125;<br><span class="hljs-comment">//slice: [2 3 4],slice addr 0xc0000044a0</span><br><span class="hljs-comment">//slice: [3 4 5],slice addr 0xc0000044c0</span><br><span class="hljs-comment">//slice: [2 11 4],slice addr 0xc0000044a0</span><br><span class="hljs-comment">//slice: [11 4 5],slice addr 0xc0000044c0</span><br></code></pre></td></tr></table></figure><ul><li>我们看这个例子，有一个5个元素的数组，slice，slice2分别截取了数组的一部分，并且有共同的一部分，我们现在能明确的就是，<strong>两个切片共用一个数组</strong>，所以一个改变都改变，还有就是<strong>两个数组是两个不同的对象，很明显内存地址不同</strong></li><li>从数组中切一块下来形成切片很好理解，有时候我们用make函数创建切片，实际上golang会在底层创建一个匿名的数组。如果从新的slice再切，那么<strong>新创建的两个切片都共享这个底层的匿名数组</strong></li></ul><h1 id="作为函数切片的参数"><a href="#作为函数切片的参数" class="headerlink" title="作为函数切片的参数"></a>作为函数切片的参数</h1><p>回到最开始的问题，当函数的参数是切片的时候，到底是传值还是传引用？从changeSlice函数中打出的参数s的地址，可以看出肯定不是传引用，毕竟引用都是一个地址才对。然而changeSlice函数内改变了s的值，也改变了原始变量slice的值，这个看起来像引用的现象，实际上正是我们前面讨论的切片共享底层数组的实现</p><p><strong>即切片传递的时候，传的是数组的值</strong>，等效于从原始切片中再切了一次。<strong>原始切片slice和参数s切片的底层数组是一样的</strong>。因此修改函数内的切片，也就修改了数组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   num := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;<br>   SliceTest3(num)<br>   fmt.Println(num)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SliceTest3</span><span class="hljs-params">(num []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>num = <span class="hljs-built_in">append</span>(num, <span class="hljs-number">2</span>)<br>fmt.Println(num)<br>&#125;<br><span class="hljs-comment">//[0 1 2]</span><br><span class="hljs-comment">//[0 1]</span><br></code></pre></td></tr></table></figure><p>Slice或者array作为函数参数传递的时候，<strong>本质是传值而不是传引用</strong>。传值的过程复制一个新的切片，这个切片也指向原始变量的底层数组。（个人感觉称之为传切片可能比传值的表述更准确）。函数中无论是直接修改切片，还是append创建新的切片，都是基于共享切片底层数组的情况作为基础。也就是最外面的原始切片是否改变，取决于函数内的操作和切片本身容量</p><p>​    </p><p><strong>如果想要传引用的时候怎么办的，则传地址即可</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   num := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>   SliceTest4(&amp;num)<br>   fmt.Println(num)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SliceTest4</span><span class="hljs-params">(num *[]<span class="hljs-keyword">int</span>)</span></span> &#123;<br>   *num = <span class="hljs-built_in">append</span>(*num, <span class="hljs-number">2</span>)<br>   fmt.Println(*num)<br>&#125;<br><span class="hljs-comment">//[0 1 2]</span><br><span class="hljs-comment">//[0 1 2]</span><br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>golang提供了array和slice两种序列结构。其中array是值类型。<strong>slice则是复合类型</strong>。slice是基于array实现的。slice的第一个内容为指向数组的指针，然后是其长度和容量。通过array的切片可以切出slice，也可以使用make创建slice，此时golang会生成一个匿名的数组</p><p>因为slice依赖其底层的array，修改slice本质是修改array，而array又是有大小限制，当超过slice的容量，即数组越界的时候，需要通过动态规划的方式创建一个新的数组块。把原有的数据复制到新数组<strong>，这个新的array则为slice新的底层依赖</strong></p><p>数组还是切片，在函数中传递的不是引用，是另外一种值类型，即通过原始变量进行切片传入。函数内的操作即对切片的修改操作了。当然，<strong>如果为了修改原始变量，可以指定参数的类型为指针类型</strong>。传递的就是slice的内存地址。函数内的操作都是根据内存地址找到变量本身</p><p>​    </p><p><strong>则在最开始db层操作中，因为传入的肯定是空的model切片，在查找时必定会发生扩容，则此时就需要传入切片指针才行</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GORM v2的使用</title>
    <link href="/2021/07/21/Gorm_v2/"/>
    <url>/2021/07/21/Gorm_v2/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前一直使用的是<code>Gorm</code>的v1，有些地方也觉得不方便，正好今天需要在原生sql语句后用count计数功能，则看了<code>Gorm</code>版本v2的更新，发现有很多新的玩法，就记录下自己工作中遇到的情况</p><p><a href="https://gorm.io/zh_CN/docs/index.html">Gorm官方文档</a></p><p><a href="https://learnku.com/docs/gorm/v2/connecting_to_the_database/9731">Gorm文档</a></p><h1 id="安装Gorm-v2"><a href="#安装Gorm-v2" class="headerlink" title="安装Gorm v2"></a>安装Gorm v2</h1><p>GORM 官方支持的数据库类型有： <code>MySQL</code>, <code>PostgreSQL</code>, <code>SQlite</code>, <code>SQL Server</code></p><figure class="highlight maxima"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">go</span> <span class="hljs-built_in">get</span> -u gorm.io/gorm<br><span class="hljs-built_in">go</span> <span class="hljs-built_in">get</span> -u gorm.io/driver/sqlite<br></code></pre></td></tr></table></figure><p>如果安装<code>sqlite</code>可能会报错</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">exec</span>: <span class="hljs-string">&quot;gcc&quot;</span>: executable <span class="hljs-keyword">file</span> not found <span class="hljs-keyword">in</span> %PATH%<br></code></pre></td></tr></table></figure><p>原因是<code>sqlite 3</code>是个<code>cgo</code>库，需要<code>gcd</code>编译c代码，需要安装<code>mingw</code></p><p><strong>解决方法</strong></p><ul><li><p><a href="https://sourceforge.net/projects/mingw-w64/files/?source=navbar">下载mingw安装包</a></p></li><li><p>解压后将bin路径加入环境变量</p></li><li><p>终端中输入<code> gcc --version</code>有相关信息则说明安装成功</p></li></ul><p>添加后如果<strong>还是运行失败</strong>，就是环境变量更改未生效，<strong>重启电脑</strong>就可以了</p><h1 id="安装Msyql驱动并使用"><a href="#安装Msyql驱动并使用" class="headerlink" title="安装Msyql驱动并使用"></a>安装Msyql驱动并使用</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">go get gorm.io<span class="hljs-regexp">/driver/my</span>sql<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  dsn := <span class="hljs-string">&quot;user:password@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span><br>  db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就比v1体验更好，v1中经常忘记引入驱动 <strong><code>import _ &quot;github.com/jinzhu/gorm/dialects/mysql&quot;</code></strong></p><p>Mysql驱动程序提供了一些<strong>高级配置</strong>可以在初始化的时候使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">db, err := gorm.Open(mysql.New(mysql.Config&#123;<br>  DSN: <span class="hljs-string">&quot;gorm:gorm@tcp(127.0.0.1:3306)/gorm?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span>, <span class="hljs-comment">// DSN data source name</span><br>  DefaultStringSize: <span class="hljs-number">256</span>, <span class="hljs-comment">// string 类型字段的默认长度</span><br>  DisableDatetimePrecision: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 禁用 datetime 精度，MySQL 5.6 之前的数据库不支持</span><br>  DontSupportRenameIndex: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 重命名索引时采用删除并新建的方式，MySQL 5.7 之前的数据库和 MariaDB 不支持重命名索引</span><br>  DontSupportRenameColumn: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 用 `change` 重命名列，MySQL 8 之前的数据库和 MariaDB 不支持重命名列</span><br>  SkipInitializeWithVersion: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 根据当前 MySQL 版本自动配置</span><br>&#125;), &amp;gorm.Config&#123;&#125;)<br></code></pre></td></tr></table></figure><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><blockquote><p>原生sql语句</p></blockquote><p>通过db.Raw设置sql语句，通过Scan执行查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">db.Raw(&quot;SELECT id, name, age FROM users WHERE id = ?&quot;, 3).Scan(&amp;result)<br></code></pre></td></tr></table></figure><p><strong>使用原生sql后的<code>Scan</code>不能跟<code>Count</code></strong></p><p><code>Exec</code> 原生 SQL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">db.Exec(&quot;UPDATE orders SET shipped_at=? WHERE id IN ?&quot;, time.Now(), []int64&#123;1,2,3&#125;)<br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>raw后接count</p></blockquote><p>在GORM v1中使用原生sql语句<code>Raw</code>后不能接<code>Find</code>，只能<code>Scan</code>，并且<code>Scan</code>后不能使用计数<code>Count</code></p><p>在v2中<code>Scan</code>后可以接<code>Count</code>，并且<code>Raw</code>后也可以接<code>Find</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">DB.DB.Raw(<span class="hljs-string">&quot;select *from articles where user_id = ? &quot;</span>,u.ID).Find(&amp;articles).Count(&amp;count).Error<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">DB.DB.Raw(<span class="hljs-string">&quot;select *from articles where user_id = ? &quot;</span>,u.ID).Scan(&amp;articles).Count(&amp;count).Error<br></code></pre></td></tr></table></figure><p>​    </p><blockquote><p>预加载</p></blockquote><p>GORM v2 允许在 <code>Preload</code> 的其它 SQL 中直接加载关系</p><p>例如：user中有card数组，使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Preload(<span class="hljs-string">&quot;Cards&quot;</span>).Find(&amp;users)<br></code></pre></td></tr></table></figure><p>就可以将相关card信息从cards数据表中也添加到users结构体中</p><p>​    </p><blockquote><p>命名参数</p></blockquote><p>GORM 支持 <code>sql.Named</code>、<code>map[string]interface&#123;&#125;&#123;&#125;</code> 的命名参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">DB.DB.Model(model.Article&#123;&#125;).Where(<span class="hljs-string">&quot;user_id=@id&quot;</span>, sql.Named(<span class="hljs-string">&quot;id&quot;</span>, u.ID)).Find(&amp;articles).Count(&amp;count).Error<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">DB.DB.Raw(<span class="hljs-string">&quot;select *from articles where user_id = @id &quot;</span>, <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;id&quot;</span>:u.ID&#125;).Scan(&amp;articles).Error<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>GORM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决github和gitlab多账户管理ssh冲突问题</title>
    <link href="/2021/07/19/git%E4%B8%8D%E5%90%8C%E4%BB%93%E5%BA%93ssh%E5%86%B2%E7%AA%81/"/>
    <url>/2021/07/19/git%E4%B8%8D%E5%90%8C%E4%BB%93%E5%BA%93ssh%E5%86%B2%E7%AA%81/</url>
    
    <content type="html"><![CDATA[<p><strong>问题</strong>  </p><blockquote><p>解决github和gitlab多账户管理ssh冲突问题</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs sh">git@gitlab.com: Permission denied<br>or<br>git@github.com: Permission denied<br></code></pre></td></tr></table></figure><p>本地邮箱是识别的唯一手段，在实际生活中采用同一个邮箱对不同仓库进行开发可能性不是很大，<strong>因为公司会给予新员工新的邮箱</strong>，而本地的ssh只会标记一个邮箱，则使用不同邮箱会冲突    </p><p>​    </p><p><strong>解决方法</strong>  </p><blockquote><p>基于config文件</p></blockquote><ul><li><p>进入 <code>/c/Users/user_name/.ssh</code> 也就是 <code>~/.ssh</code></p></li><li><p>将不同的ssh放入不同文件，生成密钥时选择对应文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">ssh-keygen -t rsa -C 不同的邮箱 <br><span class="hljs-comment">#不指定文件名则在 ~/.ssh 目录默认生成</span><br>ssh-keygen -t rsa -f ~/.ssh/gitlabsshkey -C 不同的邮箱<br><span class="hljs-comment">#指定gitlab的ssh生成的目录位置</span><br></code></pre></td></tr></table></figure></li><li><p>设置配置文件（在 <code>~/.ssh/config</code>,没有就手动创建 <code>touch config</code>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">Host github.com  <br>    HostName github.com  <br>    PreferredAuthentications publickey  <br>    IdentityFile ~/.ssh/id_rsa  #这里是GitHub生成sshkey的那个文件路径<br><br>Host gitlab.com<br>    HostName xx.xx.xx #填写对应公司的仓库地址<br>    PreferredAuthentications publickey  <br>    IdentityFile ~/.ssh/gitlabsshkey/id_rsa  #这里是GitHub生成sshkey的那个文件路径<br></code></pre></td></tr></table></figure></li></ul><p>​    </p><p><strong>进行验证</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -T git@github.com #如果你用的是github<br><span class="hljs-meta">#</span><span class="bash">Hi xxx! You<span class="hljs-string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span> <br>ssh -T git@gitlab.com #如果你用的是gitlab<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-string">Welcome to GitLab, xxx!</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新篇章</title>
    <link href="/2021/07/07/%E6%96%B0%E7%AF%87%E7%AB%A0/"/>
    <url>/2021/07/07/%E6%96%B0%E7%AF%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<ul><li><p>很早前就想弄一个自己的博客了。但是因为各种原因 (主要还是自己懒) 就没有弄，平时自己也会通过typora写一点笔记，在后续也会慢慢整理发布</p></li><li><p>现在出来实习了，也顺便记录一下平时的工作心得和知识，欢迎大家纠正和讨论</p></li><li><p>取名为新的篇章也算是应景了，大三下出来实习也算是正式告别学生身份了，以打工人的身份拥抱社会，也不管前方要面对什么，冲冲冲就完事了</p></li><li><p>保持热情，保持激情！</p></li><li><p>扬帆  启航！</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
